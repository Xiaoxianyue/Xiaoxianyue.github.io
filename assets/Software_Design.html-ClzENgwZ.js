import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,o as a,b as i}from"./app-Bd78-QqM.js";const o="/assets/image-20240430182403008-DbyAI_Qe.png",n="/assets/image-20240430184036676-OuSGVSuv.png",s="/assets/image-20240430194008040-VSvBOk12.png",r="/assets/image-20240430194238175-C5-zznUm.png",p="/assets/image-20240430194426589-C9AaXA83.png",l="/assets/image-20240430194610804-BvUv9ftS.png",c="/assets/image-20240430195010955-D0ql4P_0.png",g="/assets/image-20240430200856355-CzfY63GX.png",d="/assets/image-20240430201200839-nBimaPAr.png",h="/assets/image-20240430201654442-BHZshrrn.png",u="/assets/image-20240430201739762-DfyyxCHy.png",m="/assets/image-20240430202126724-QmB6gQqs.png",f="/assets/image-20240430202525286-D4S9eEBX.png",_="/assets/image-20240430202721403-m3T4wJeP.png",y="/assets/image-20240430204822059-B-OF9t4Y.png",b="/assets/image-20240430205116810-rEnMjXi1.png",w="/assets/image-20240430205232035-Bob5X3rx.png",x="/assets/image-20240430205413802-BpIC1N9f.png",k="/assets/image-20240430205818386-B4F17i8j.png",v="/assets/image-20240430205838904-Cxmt_dfQ.png",S="/assets/image-20240430210013700-BltP4QEk.png",q={},D=i('<h2 id="_1-methodology" tabindex="-1"><a class="header-anchor" href="#_1-methodology"><span>1. Methodology</span></a></h2><h3 id="_1-1-define" tabindex="-1"><a class="header-anchor" href="#_1-1-define"><span>1.1 Define</span></a></h3><p>−a paradigm(i.e. approach) to be used</p><p>−a precise lifecycle to be used (and further sub stages)</p><p>−the exact modelling and other proven techniquesto be used at each lifecycle stage (defining how they are to be used).</p><p>​ a commercial Computer Aided Software Engineering (CASE) tool often used (such as Visual Paradigm for business process modelling and object oriented design)</p><p>方法定义</p><p>-要使用的范例（即方法）</p><p>-要使用的精确生命周期（以及更多的子阶段）</p><p>-每个生命周期阶段要使用的精确建模和其他经过验证的技术（定义如何使用这些技术）。</p><p>经常使用的商业计算机辅助软件工程（CASE）工具（如用于业务流程建模和面向对象设计的 Visual Paradigm）。</p><h3 id="_1-2-types" tabindex="-1"><a class="header-anchor" href="#_1-2-types"><span>1.2 Types</span></a></h3><ol><li>Structured (function-oriented): 1970s</li><li>Object-oriented (OO):1990s  <ul><li>Unified Process (UP): e.g. IBM Rational Unified Process (RUP) provides a framework for object oriented software engineering using</li><li><strong>Unified Modelling Language (UML)</strong>: a standard language for visualising(可视化）, specifying（指定）, constructing（构建） and documenting（记录） software artefacts.</li></ul></li></ol><h4 id="_1-2-1-structured-methodology" tabindex="-1"><a class="header-anchor" href="#_1-2-1-structured-methodology"><span>1.2.1 Structured Methodology</span></a></h4><p>−Processes manipulate data and show how processes transform data that flow through the system</p><p>−Considers the processes and data separately</p><p>-流程操作数据，显示流程如何转换流经系统的数据</p><p>-将流程和数据分开考虑</p><blockquote><p>Structured Methodology提供一种操作数据的结构和流程, 数据流经这些结构(流程), 产生结果,像工厂线生产一样.</p></blockquote><img src="'+o+'" alt="image-20240430182403008" style="zoom:50%;"><h4 id="_1-2-2-object-oriented-methodology" tabindex="-1"><a class="header-anchor" href="#_1-2-2-object-oriented-methodology"><span>1.2.2 Object-oriented Methodology</span></a></h4><p>Based on the concept of objects in which data is encapsulated with the functions that act on the data (opposed to the data passing through functions, e.g. withdraw, in the function oriented approach)</p><p>基于对象的概念，在对象中，数据与作用于数据的函数封装在一起（与面向函数的方法中数据通过函数传递（如撤回）相反）。</p><blockquote><p>操作与数据被封装在相关的对象里,需要该对象时一起调用.</p></blockquote><img src="'+n+'" alt="image-20240430184036676" style="zoom:67%;"><h5 id="_1-2-1-1-design-techniques" tabindex="-1"><a class="header-anchor" href="#_1-2-1-1-design-techniques"><span>1.2.1.1 Design Techniques</span></a></h5><ul><li>Structural Design −Focuses on static aspects of the software system −Techniques: e.g. class diagram, object diagram, component diagram, etc.</li><li>Behavioural Design −Focuses on dynamic aspects of the software system −Techniques: e.g. activity diagram, sequence diagram</li></ul><p>结构设计 - 侧重于软件系统的静态方面 - 技术：如类图、对象图、组件图等</p><p>行为设计 - 侧重于软件系统的动态方面 - 技术：如活动图、序列图等</p><h5 id="_1-2-1-2-oo-software-design-uml" tabindex="-1"><a class="header-anchor" href="#_1-2-1-2-oo-software-design-uml"><span>1.2.1.2 OO Software Design: UML</span></a></h5><p>分为结构图和行为图</p><figure><img src="'+s+'" alt="image-20240430194008040" tabindex="0" loading="lazy"><figcaption>image-20240430194008040</figcaption></figure><h2 id="_2-some-principle" tabindex="-1"><a class="header-anchor" href="#_2-some-principle"><span>2. some principle</span></a></h2><h3 id="_2-1-abstraction" tabindex="-1"><a class="header-anchor" href="#_2-1-abstraction"><span>2.1 Abstraction</span></a></h3><figure><img src="'+r+'" alt="image-20240430194238175" tabindex="0" loading="lazy"><figcaption>image-20240430194238175</figcaption></figure><h3 id="_2-2-modularity-separation-of-concerns" tabindex="-1"><a class="header-anchor" href="#_2-2-modularity-separation-of-concerns"><span>2.2 Modularity &amp; Separation of Concerns</span></a></h3><p><strong>Modularity</strong></p><figure><img src="'+p+'" alt="image-20240430194426589" tabindex="0" loading="lazy"><figcaption>image-20240430194426589</figcaption></figure><blockquote><p>模块化编程。模块内部成员联系紧密，模块之间关系尽量少。</p></blockquote><h3 id="_2-2-1-separation-of-concerns" tabindex="-1"><a class="header-anchor" href="#_2-2-1-separation-of-concerns"><span>2.2.1 <strong>Separation of Concerns</strong></span></a></h3><figure><img src="'+l+'" alt="image-20240430194610804" tabindex="0" loading="lazy"><figcaption>image-20240430194610804</figcaption></figure><p>−Refers to a given problem that involves different areas of concerns to be identified and separated to deal with complexity, and to achieve required engineering quality)</p><p>−For example: The inputs/outputs, logic of a program are separated from data/data storage (whose primary concern is to about the entities, things that system needs to store information about).</p><p>-指一个给定的问题，该问题涉及不同的关注领域，需要加以识别和区分，以处理复杂性，并达到所要求的工程质量。）</p><p>-例如程序的输入/输出、逻辑与数据/数据存储（主要关注系统需要存储信息的实体、事物）分离。</p><figure><img src="'+c+'" alt="image-20240430195010955" tabindex="0" loading="lazy"><figcaption>image-20240430195010955</figcaption></figure><p>Example:</p><p>Building an application in Python modules for communication below:</p><p>−Inputs and outputs (interface)</p><p>−Logic (e.g. process, computation, business or application logic)</p><p>−Data (Data storage: for data persistence, e.g. database</p><h2 id="_3-separation-of-concerns-python" tabindex="-1"><a class="header-anchor" href="#_3-separation-of-concerns-python"><span>3. <strong>Separation of Concerns(Python)</strong></span></a></h2><p><strong>Python modules: Employee application</strong></p><h3 id="_3-1-input-and-output" tabindex="-1"><a class="header-anchor" href="#_3-1-input-and-output"><span>3.1 input and output</span></a></h3><p>:the submit_details method to take inputs from the keyboard; the display method to display result to the user.</p><figure><img src="'+g+'" alt="image-20240430200856355" tabindex="0" loading="lazy"><figcaption>image-20240430200856355</figcaption></figure><h3 id="_3-2-logic" tabindex="-1"><a class="header-anchor" href="#_3-2-logic"><span>3.2 Logic</span></a></h3><p>the upload_employee_list and add_employee methods to upload(上传) the employee list and add a new employee to the list</p><figure><img src="'+d+'" alt="image-20240430201200839" tabindex="0" loading="lazy"><figcaption>image-20240430201200839</figcaption></figure><h3 id="_3-3-data-access" tabindex="-1"><a class="header-anchor" href="#_3-3-data-access"><span>3.3 Data access</span></a></h3><p>the read_employee and write_employee method to read and write the employee data to a list</p><figure><img src="'+h+'" alt="image-20240430201654442" tabindex="0" loading="lazy"><figcaption>image-20240430201654442</figcaption></figure><h3 id="_3-4-testing-module" tabindex="-1"><a class="header-anchor" href="#_3-4-testing-module"><span>3.4 testing module</span></a></h3><figure><img src="'+u+'" alt="image-20240430201739762" tabindex="0" loading="lazy"><figcaption>image-20240430201739762</figcaption></figure><h3 id="_3-5-results" tabindex="-1"><a class="header-anchor" href="#_3-5-results"><span>3.5 results</span></a></h3><figure><img src="'+m+'" alt="image-20240430202126724" tabindex="0" loading="lazy"><figcaption>image-20240430202126724</figcaption></figure><h2 id="_4-interface-design" tabindex="-1"><a class="header-anchor" href="#_4-interface-design"><span>4. Interface Design</span></a></h2><h3 id="_4-1-prototyping-原型设计" tabindex="-1"><a class="header-anchor" href="#_4-1-prototyping-原型设计"><span>4.1 Prototyping 原型设计</span></a></h3><p>Prototyping: for inputs and outputs</p><p><strong>1. Storyboard</strong></p><figure><img src="'+f+'" alt="image-20240430202525286" tabindex="0" loading="lazy"><figcaption>image-20240430202525286</figcaption></figure><p><strong>2. wireframe</strong></p><h4 id="_4-1-1-wireframe" tabindex="-1"><a class="header-anchor" href="#_4-1-1-wireframe"><span>4.1.1 wireframe</span></a></h4><figure><img src="'+_+'" alt="image-20240430202721403" tabindex="0" loading="lazy"><figcaption>image-20240430202721403</figcaption></figure><ul><li><p><strong>What is wireframe?</strong></p><p>basic blueprints that help teams follow the requirements keeping UX/UI design conversations focused and constructive</p></li></ul><blockquote><p>帮助团队遵循需求的基本蓝图，保持用户体验/用户界面设计对话的重点和建设性</p></blockquote><ul><li><p><strong>Wireframe includes:</strong></p><ul><li>Screen layouts 屏幕布局</li><li>Navigation bars 导航栏</li><li>Components of UX and UI design 用户体验和用户界面设计的组成部分</li><li>Interactive elements 互动元素</li></ul></li><li><p><strong>Types：</strong></p><p>Low-fidelity wireframes</p><p>Mid-fidelity wireframes</p><p>High-fidelity wireframes</p></li></ul><p>高中低保真率。</p><blockquote><p>根据不同尺寸的屏幕来设置</p></blockquote><ul><li><p><strong>To design the best wireframe</strong></p><p>• Identify your design goals 明确目标</p><p>•Choose the right size for your wireframe 选择屏幕尺寸</p><p>​ –e.g. 14” laptop screen 1920 x 1080 resolution–Mobile phone or Tablet</p><p>•Keep your wireframe design simple 简单设计</p><p>•Maintain design consistency 保持设计一致性</p><p>•Make navigation obvious 使导航一目了然</p><p>•Don’t get too attached to a frame creative design 不要过于执着于框架创意设计</p><p>•Use the tools for wireframing 使用工具进行线框设计</p></li><li><p><strong>Wireframe design checklist</strong></p></li></ul><p>• What screens are essential to meet user needs</p><p>• User flow through conversion funnels</p><p>• Usability considerations, including navigation and organization</p><p>• Main goals and user flows for each screen</p><p>• Key UI design elements, plus content and interactive features on each screen</p><p>• How design components fit together to form screen templates</p><ul><li><p>哪些屏幕对满足用户需求至关重要</p></li><li><p>用户在转换中的流动</p></li><li><p>可用性考虑因素，包括导航和组织</p></li><li><p>每个屏幕的主要目标和用户流程</p></li><li><p>关键的用户界面设计元素，以及每个屏幕上的内容和互动功能</p></li><li><p>设计组件如何组合成屏幕模板</p></li><li><p><strong>success criteria</strong></p></li></ul><p>•Can users can get through the UX without instructions?</p><p>•Creative sessions with stackeholders –are the wireframes aligned with the needs?</p><p>•Aesthetic considerations VS functionality ?</p><p>-用户能否在没有说明的情况下使用用户体验？</p><p>-与相关人员举行创意会议 -线框图是否符合需求？</p><p>-美学考虑与功能性对比？</p><h2 id="_5-flowchart-for-algorithmic" tabindex="-1"><a class="header-anchor" href="#_5-flowchart-for-algorithmic"><span>5. Flowchart for Algorithmic</span></a></h2><p><strong>Algorithmic Approach</strong>——gives sequence of the steps; no need to concern about efficiency at analysis stage 无需分析阶段的效率</p><blockquote><p>算法就是一个解决问题的模型的步骤</p></blockquote><p><strong>Flowchart</strong>: to model program control structures</p><blockquote><p>流程图直观地展示算法的步骤</p></blockquote><p>Example：checking temperature</p><figure><img src="'+y+'" alt="image-20240430204822059" tabindex="0" loading="lazy"><figcaption>image-20240430204822059</figcaption></figure><p>Sale check out process</p><figure><img src="'+b+'" alt="image-20240430205116810" tabindex="0" loading="lazy"><figcaption>image-20240430205116810</figcaption></figure><h3 id="_5-1-notation" tabindex="-1"><a class="header-anchor" href="#_5-1-notation"><span>5.1 Notation</span></a></h3><figure><img src="'+w+'" alt="image-20240430205232035" tabindex="0" loading="lazy"><figcaption>image-20240430205232035</figcaption></figure><p>loop：</p><figure><img src="'+x+'" alt="image-20240430205413802" tabindex="0" loading="lazy"><figcaption>image-20240430205413802</figcaption></figure><h3 id="_5-2-algorithmic-approach" tabindex="-1"><a class="header-anchor" href="#_5-2-algorithmic-approach"><span>5.2 Algorithmic Approach</span></a></h3><ol><li><p>Structured English: programming language independent</p><figure><img src="'+k+'" alt="image-20240430205818386" tabindex="0" loading="lazy"><figcaption>image-20240430205818386</figcaption></figure></li><li><p>Pseudo-code: uses syntax of a specific programming language 伪代码：使用特定编程语言的语法</p></li></ol><figure><img src="'+v+'" alt="image-20240430205838904" tabindex="0" loading="lazy"><figcaption>image-20240430205838904</figcaption></figure><h3 id="_5-3-non-algorithmic-approach" tabindex="-1"><a class="header-anchor" href="#_5-3-non-algorithmic-approach"><span>5.3 Non-Algorithmic Approach</span></a></h3><p>describes an operation logic as a black box</p><ul><li><p>Pre- and post-conditions:</p><p>What conditions must be satisfied before an operation can take place?</p><p>What conditions and states may the system be in after an operation is completed?</p></li></ul><p>Example: sale.getTotalPrice(): Money</p><figure><img src="'+S+'" alt="image-20240430210013700" tabindex="0" loading="lazy"><figcaption>image-20240430210013700</figcaption></figure>',114),z=[D];function P(M,A){return a(),t("div",null,z)}const U=e(q,[["render",P],["__file","Software_Design.html.vue"]]),B=JSON.parse('{"path":"/zh/Software_Design/Software_Design.html","title":"Software Design technique","lang":"zh-CN","frontmatter":{"title":"Software Design technique","icon":"c","date":"2024-04-30T17:58:42.000Z","author":"XiaoXianYue","isOriginal":true,"category":["Python","大二下"],"tag":["Python","大二下"],"sticky":false,"star":false,"article":true,"timeline":true,"image":false,"navbar":true,"sidebarIcon":true,"headerDepth":5,"lastUpdated":true,"editLink":false,"backToTop":true,"toc":true,"description":"1. Methodology 1.1 Define −a paradigm(i.e. approach) to be used −a precise lifecycle to be used (and further sub stages) −the exact modelling and other proven techniquesto be us...","head":[["meta",{"property":"og:url","content":"https://bougiemoonintaurus/zh/Software_Design/Software_Design.html"}],["meta",{"property":"og:site_name","content":"奶酪奶酪"}],["meta",{"property":"og:title","content":"Software Design technique"}],["meta",{"property":"og:description","content":"1. Methodology 1.1 Define −a paradigm(i.e. approach) to be used −a precise lifecycle to be used (and further sub stages) −the exact modelling and other proven techniquesto be us..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-09T17:01:37.000Z"}],["meta",{"property":"article:author","content":"XiaoXianYue"}],["meta",{"property":"article:tag","content":"Python"}],["meta",{"property":"article:tag","content":"大二下"}],["meta",{"property":"article:published_time","content":"2024-04-30T17:58:42.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-09T17:01:37.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Software Design technique\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-04-30T17:58:42.000Z\\",\\"dateModified\\":\\"2024-05-09T17:01:37.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"XiaoXianYue\\"}]}"]]},"headers":[{"level":2,"title":"1. Methodology","slug":"_1-methodology","link":"#_1-methodology","children":[{"level":3,"title":"1.1 Define","slug":"_1-1-define","link":"#_1-1-define","children":[]},{"level":3,"title":"1.2 Types","slug":"_1-2-types","link":"#_1-2-types","children":[{"level":4,"title":"1.2.1 Structured  Methodology","slug":"_1-2-1-structured-methodology","link":"#_1-2-1-structured-methodology","children":[]},{"level":4,"title":"1.2.2 Object-oriented Methodology","slug":"_1-2-2-object-oriented-methodology","link":"#_1-2-2-object-oriented-methodology","children":[{"level":5,"title":"1.2.1.1 Design Techniques","slug":"_1-2-1-1-design-techniques","link":"#_1-2-1-1-design-techniques","children":[]},{"level":5,"title":"1.2.1.2  OO Software Design: UML","slug":"_1-2-1-2-oo-software-design-uml","link":"#_1-2-1-2-oo-software-design-uml","children":[]}]}]}]},{"level":2,"title":"2. some principle","slug":"_2-some-principle","link":"#_2-some-principle","children":[{"level":3,"title":"2.1 Abstraction","slug":"_2-1-abstraction","link":"#_2-1-abstraction","children":[]},{"level":3,"title":"2.2 Modularity & Separation of Concerns","slug":"_2-2-modularity-separation-of-concerns","link":"#_2-2-modularity-separation-of-concerns","children":[]},{"level":3,"title":"2.2.1 Separation of Concerns","slug":"_2-2-1-separation-of-concerns","link":"#_2-2-1-separation-of-concerns","children":[]}]},{"level":2,"title":"3. Separation of Concerns(Python)","slug":"_3-separation-of-concerns-python","link":"#_3-separation-of-concerns-python","children":[{"level":3,"title":"3.1 input and output","slug":"_3-1-input-and-output","link":"#_3-1-input-and-output","children":[]},{"level":3,"title":"3.2 Logic","slug":"_3-2-logic","link":"#_3-2-logic","children":[]},{"level":3,"title":"3.3 Data access","slug":"_3-3-data-access","link":"#_3-3-data-access","children":[]},{"level":3,"title":"3.4  testing  module","slug":"_3-4-testing-module","link":"#_3-4-testing-module","children":[]},{"level":3,"title":"3.5  results","slug":"_3-5-results","link":"#_3-5-results","children":[]}]},{"level":2,"title":"4.  Interface Design","slug":"_4-interface-design","link":"#_4-interface-design","children":[{"level":3,"title":"4.1 Prototyping 原型设计","slug":"_4-1-prototyping-原型设计","link":"#_4-1-prototyping-原型设计","children":[{"level":4,"title":"4.1.1 wireframe","slug":"_4-1-1-wireframe","link":"#_4-1-1-wireframe","children":[]}]}]},{"level":2,"title":"5. Flowchart for Algorithmic","slug":"_5-flowchart-for-algorithmic","link":"#_5-flowchart-for-algorithmic","children":[{"level":3,"title":"5.1 Notation","slug":"_5-1-notation","link":"#_5-1-notation","children":[]},{"level":3,"title":"5.2 Algorithmic Approach","slug":"_5-2-algorithmic-approach","link":"#_5-2-algorithmic-approach","children":[]},{"level":3,"title":"5.3 Non-Algorithmic Approach","slug":"_5-3-non-algorithmic-approach","link":"#_5-3-non-algorithmic-approach","children":[]}]}],"git":{"createdTime":1714482031000,"updatedTime":1715274097000,"contributors":[{"name":"Xiaoxianyue","email":"2310219843@qq.com","commits":6}]},"readingTime":{"minutes":5.28,"words":1584},"filePathRelative":"zh/Software_Design/Software_Design.md","localizedDate":"2024年4月30日","excerpt":"<h2>1. Methodology</h2>\\n<h3>1.1 Define</h3>\\n<p>−a paradigm(i.e. approach) to be used</p>\\n<p>−a precise lifecycle to be used (and further sub stages)</p>\\n<p>−the exact modelling and other proven techniquesto  be used at each lifecycle stage (defining how they  are to be used).</p>\\n<p>​    a commercial Computer Aided Software  Engineering (CASE) tool often used (such as  Visual Paradigm for business process modelling  and object oriented design)</p>","autoDesc":true}');export{U as comp,B as data};
