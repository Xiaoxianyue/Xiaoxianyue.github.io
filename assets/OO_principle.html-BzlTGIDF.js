import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,o as a,b as t}from"./app-BELnPu44.js";const o="/assets/image-20240423102031569-BbpxF06M.png",n="/assets/image-20240423102404092-eZ9vY6PZ.png",s="/assets/image-20240423102744478-DXZodIGD.png",r="/assets/image-20240423103413414-CirmgYP0.png",l="/assets/image-20240423103925881-B4iuAX6L.png",p="/assets/image-20240423104156920-CayP9Wve.png",c="/assets/image-20240423104702345-DfwKyDW_.png",g="/assets/image-20240423105936976-DhSer4Ts.png",d="/assets/image-20240423153428804-B9hbQefG.png",h="/assets/image-20240423154427813-C_BaYOc1.png",m="/assets/image-20240423155241627-Bl8s_04d.png",u="/assets/image-20240423155936427-D_8Pc7NW.png",f="/assets/image-20240423160749385-CjF9EuRY.png",b="/assets/image-20240423162103799-G3BsxBvO.png",_="/assets/image-20240423163517571-DioYZIXQ.png",y="/assets/image-20240423165820855-Cy_vtyxW.png",v="/assets/image-20240423170749970-Dg648Mfq.png",w="/assets/image-20240423171001674-CSpn_h_5.png",x="/assets/image-20240423171900474-BrOyd67B.png",C="/assets/image-20240423172854588-CPSCNNzz.png",k="/assets/image-20240423232858885-D0DoMzS1.png",S="/assets/image-20240424020557350-Bo0IsuIe.png",O="/assets/image-20240424022601361-B2XjJPL4.png",P="/assets/image-20240424023245910-e6DfeCPr.png",j="/assets/image-20240424025011384-C-u3E3hM.png",z="/assets/image-20240424030426766-Bhmpv1Xb.png",D="/assets/image-20240424032047929-Cb08YtT7.png",A={},q=t('<h2 id="_1-oo-software-design-concepts" tabindex="-1"><a class="header-anchor" href="#_1-oo-software-design-concepts"><span>1. OO Software Design Concepts</span></a></h2><img src="'+o+'" alt="image-20240423102031569" style="zoom:80%;"><h3 id="_1-1-abstraction" tabindex="-1"><a class="header-anchor" href="#_1-1-abstraction"><span>1.1 Abstraction</span></a></h3><ul><li>Data abstraction: The developer and other objects in the system have a high level summary view (an abstract view) of what data items are. It contains the required information about an object.</li><li>Procedure abstraction: A high level summary view of the operations provided. The details and how the methods are coded are ignored.</li></ul><p>就是变量名称和方法名称要简单直接。比如我们想输出一个人的姓名，方法可以叫printname。</p><img src="'+n+'" alt="image-20240423102404092" style="zoom:80%;"><h3 id="_1-2-encapsulation" tabindex="-1"><a class="header-anchor" href="#_1-2-encapsulation"><span>1.2 Encapsulation</span></a></h3><h4 id="_1-2-1-class-object" tabindex="-1"><a class="header-anchor" href="#_1-2-1-class-object"><span>1.2.1 Class/Object</span></a></h4><p>The attributes (data) relating to an object and the operations that act upon them are all encapsulated inside a single software “capsule”.</p><p>变量和操作一起被封装在对象中。</p><figure><img src="'+s+'" alt="image-20240423102744478" tabindex="0" loading="lazy"><figcaption>image-20240423102744478</figcaption></figure><h4 id="_1-2-2-aggregation-composition" tabindex="-1"><a class="header-anchor" href="#_1-2-2-aggregation-composition"><span>1.2.2 Aggregation/Composition</span></a></h4><p>via aggregation and composition to encapsulate components.</p><p>encapsulates a group of classes collectively, as a complex whole is made of similar components (parts)</p><p>把一组类封装起来。</p><figure><img src="'+r+'" alt="image-20240423103413414" tabindex="0" loading="lazy"><figcaption>image-20240423103413414</figcaption></figure><h3 id="_1-3-information-hiding" tabindex="-1"><a class="header-anchor" href="#_1-3-information-hiding"><span>1.3 Information Hiding</span></a></h3><ul><li>Data Hiding: the developer and other objects in the system have no direct access to the attributes (which are private) or the detail of how the attributes are stored.</li><li>Procedure Hiding: The developer and other objects in the system do not know the detail of how the methods work. The name of a method is public, but the code body of the method is hidden. (内置函数)</li></ul><blockquote><p>The access to the data via accessor methods (e.g get methods, get_username (); modification of the data via mutator methods (e.g. set methods, set_username ()</p></blockquote><figure><img src="'+l+'" alt="image-20240423103925881" tabindex="0" loading="lazy"><figcaption>image-20240423103925881</figcaption></figure><p>上图是Example of procedure hiding</p><h3 id="_1-4-separation-of-concerns-modularity" tabindex="-1"><a class="header-anchor" href="#_1-4-separation-of-concerns-modularity"><span>1.4 Separation of Concerns &amp; Modularity</span></a></h3><ul><li><p>Separation of Concerns − Refers to a given problem that involves different areas of concerns to be identified and separated to deal with complexity, and to achieve required engineering quality)</p></li><li><p>For example: The inputs/outputs, logic of a program are separated from data storage(whose primary concern is to store data).</p></li></ul><img src="'+p+'" alt="image-20240423104156920" style="zoom:80%;"><p>Modularity − Relating to separation of concerns</p><figure><img src="'+c+'" alt="image-20240423104702345" tabindex="0" loading="lazy"><figcaption>image-20240423104702345</figcaption></figure><p>− separating software into components/modules, according to functionality and responsibility</p><p>− ignore details of other modules when dealing with a module</p><p>− <strong>cohesion and coupling</strong></p><ul><li><p>module understandable as a meaningful unit and components of a module are closely related to one another</p></li><li><p>modules have interactions with others</p></li></ul><h4 id="_1-4-1-cohesion" tabindex="-1"><a class="header-anchor" href="#_1-4-1-cohesion"><span>1.4.1 Cohesion</span></a></h4><p>Each module should be highly cohesive: module understandable as a meaningful unit; components of a module are closely related to one another. (module内部紧密联系)</p><img src="'+g+'" alt="image-20240423105936976" style="zoom:80%;"><ol><li><strong>Operation cohesion:</strong> the degree of an operation achieves a single functional requirement.</li></ol><p>Chinese：操作实现单一功能要求的程度。</p><blockquote><p>High operation cohesion = good design</p></blockquote><figure><img src="'+d+'" alt="image-20240423153428804" tabindex="0" loading="lazy"><figcaption>image-20240423153428804</figcaption></figure><ol start="2"><li><strong>Class cohesion</strong>: the degree of a class achieves a single requirement.</li></ol><p>类实现单一功能的程度。</p><ul><li><p>A class should only have attributes and operations related to its objects（属性和操作要紧密与对象联系）</p></li><li><p>Data classes should just handle data.</p><blockquote><p>High class cohesion = good design</p></blockquote></li></ul><p>Example：</p><figure><img src="'+h+'" alt="image-20240423154427813" tabindex="0" loading="lazy"><figcaption>image-20240423154427813</figcaption></figure><p>这是一个好的软件设计吗？不是。course不是直属与student的属性。（Student class should only have attributes and operations related to its objects ）</p><figure><img src="'+m+'" alt="image-20240423155241627" tabindex="0" loading="lazy"><figcaption>image-20240423155241627</figcaption></figure><p>这样才是一个好的软件设计。</p><ol start="3"><li>Specialisation cohesion: semantic cohesion of inheritance hierarchies. Super-class and its subclasses should be closely related.</li></ol><p>超类和子类要密切关联。</p><blockquote><p>High specialisation cohesion = good design</p></blockquote><figure><img src="'+u+'" alt="image-20240423155936427" tabindex="0" loading="lazy"><figcaption>image-20240423155936427</figcaption></figure><p>下面这是一个好的软件设计吗？</p><figure><img src="'+f+'" alt="image-20240423160749385" tabindex="0" loading="lazy"><figcaption>image-20240423160749385</figcaption></figure><p>不是。Part-time Course与student联系不紧密。（Part time Course is not a type of Student.）</p><h4 id="_1-4-2-coupling" tabindex="-1"><a class="header-anchor" href="#_1-4-2-coupling"><span>1.4.2 Coupling</span></a></h4><p>Coupling: degree of interaction between objects</p><p>− Interaction coupling</p><p>– the number of message types an object sends to other objects and number of parameters passed with the messages</p><p>/一个对象发送给其他对象的信息类型数量，以及与信息一起传递的参数数量/</p><blockquote><p>Low Interaction coupling = good design</p></blockquote><ol><li>直观例子：</li></ol><p>A Student object can interact and send message to a Course object (e.g. the Course object reference, course, is placed in the attribute of the Student class), which means a Student object can call on the methods of a Course object</p><p>student 中出现了course 这就是耦合。</p><figure><img src="'+b+'" alt="image-20240423162103799" tabindex="0" loading="lazy"><figcaption>image-20240423162103799</figcaption></figure><ol start="2"><li>图示：</li></ol><ul><li>Modules should exhibit low coupling: modules have low interactions with others.(就是模块间的耦合度要小)</li><li>Strong Coupling or High Coupling (except class inheritance) should be avoided.</li></ul><figure><img src="'+_+'" alt="image-20240423163517571" tabindex="0" loading="lazy"><figcaption>image-20240423163517571</figcaption></figure><ol start="3"><li><strong>Inheritance Coupling</strong> :</li></ol><p>the features from a subclass inherited from its super class</p><blockquote><p>High inheritance coupling (i.e. Subclass inherits more its super class features) = good design</p></blockquote><p>Exercise:</p><figure><img src="'+y+'" alt="image-20240423165820855" tabindex="0" loading="lazy"><figcaption>image-20240423165820855</figcaption></figure><p>A. 因为子类继承了更多父类的feature。</p><h3 id="_1-5-reusability" tabindex="-1"><a class="header-anchor" href="#_1-5-reusability"><span>1.5 Reusability</span></a></h3><h4 id="_1-5-1-aggregation-and-composition" tabindex="-1"><a class="header-anchor" href="#_1-5-1-aggregation-and-composition"><span>1.5.1 Aggregation and composition</span></a></h4><p>encapsulates a group of classes collectively for a reuse subassembly, as a complex whole is made of similar components (parts); more parts can be added to the whole component.</p><figure><img src="'+v+'" alt="image-20240423170749970" tabindex="0" loading="lazy"><figcaption>image-20240423170749970</figcaption></figure><p>这里就是说模块和模块之间Aggregation和composition的关系。</p><h4 id="_1-5-2-generalisation-specialisation-inheritance" tabindex="-1"><a class="header-anchor" href="#_1-5-2-generalisation-specialisation-inheritance"><span>1.5.2 Generalisation/Specialisation (Inheritance)</span></a></h4><p>allows the creation of new specialised classes when needed, as new specialised subclasses will inherit the characteristics of existing superclasses; e.g. class, MSc Student, can be added to the hierarchy</p><figure><img src="'+w+'" alt="image-20240423171001674" tabindex="0" loading="lazy"><figcaption>image-20240423171001674</figcaption></figure><h4 id="_1-5-3-example" tabindex="-1"><a class="header-anchor" href="#_1-5-3-example"><span>1.5.3 Example</span></a></h4><p>A buyer, seller or an agent in an estate agent appointment booking system.</p><figure><img src="'+x+'" alt="image-20240423171900474" tabindex="0" loading="lazy"><figcaption>image-20240423171900474</figcaption></figure><p>Question: Is the following via inheritance a good design?</p><figure><img src="'+C+'" alt="image-20240423172854588" tabindex="0" loading="lazy"><figcaption>image-20240423172854588</figcaption></figure><p>不是。</p><p><strong>WHY？</strong></p><ol><li>Criterion for inheritance 1: <strong>when a subclass expresses &quot;is a special kind/type of&quot; and not &quot;is a role played by a”</strong></li></ol><p>而seller,buyer,agent is a role played by a person.</p><ol start="2"><li>Criterion for inheritance 2: <strong>An instance of a subclass never needs to become an object of another class:</strong></li></ol><p>而这个例子中，一个person可以从seller变成buyer在变成agent，所以这里最好是用Aggregation&amp;Composition关系。</p><p>当然，我们也可以这样表示这个模型：</p><figure><img src="'+k+'" alt="image-20240423232858885" tabindex="0" loading="lazy"><figcaption>image-20240423232858885</figcaption></figure><h2 id="_2-design-principle" tabindex="-1"><a class="header-anchor" href="#_2-design-principle"><span>2. Design principle</span></a></h2><h3 id="_2-1-open-closed" tabindex="-1"><a class="header-anchor" href="#_2-1-open-closed"><span>2.1 Open-Closed</span></a></h3><p>summary: Software entities should be open for extension, whilst keeping closed for modification.</p><ul><li>Open For Extension -The behaviour of the module can be extended to meet new requirements.</li><li>Closed For Modification –change to the source code of the module should be kept to a minimum.</li></ul><figure><img src="'+S+`" alt="image-20240424020557350" tabindex="0" loading="lazy"><figcaption>image-20240424020557350</figcaption></figure><h2 id="_3-design-pattern" tabindex="-1"><a class="header-anchor" href="#_3-design-pattern"><span>3. Design pattern</span></a></h2><p>上下文−a general reusable solution to a commonly occurring problem within a given context in software design</p><blockquote><p>Context helps the understanding the environment of a problem and reaching an appropriate solution</p></blockquote><p>设计模版，解决相似问题−is not a finished design to be transformed directly into code, rather a description or template for how to solve a problem that can be used in many different situations.</p><blockquote><p>A good design pattern captures design knowledge to be reusedin different settings</p></blockquote><p>Categories：</p><ul><li><p>Architectural Patterns: presenting a fundamental structural schema for a software system −e.g. “MVC” patterns</p></li><li><p>Design Patterns: providing a scheme for refining the subsystems or components of a software system</p></li><li><p>General Patterns giving fundamental approaches for assigning responsibilities to objects; basic well-known design guidelines</p><p>​ e.g. the “GRASP” set of patterns</p><ul><li>Design Patterns for more specific but common contexts/problems.</li></ul><p>​ e.g. the “Observer”</p><p>​ Usually specific enough to include a UML model of the outline solution.</p><p>类别：</p><p>-体系结构模式：为软件系统提供基本的结构模式，例如“MVC”模式</p><p>-设计模式：提供细化软件系统的子系统或组件的方案</p><p>−通用模式，给出了将责任分配给对象的基本方法；众所周知的基本设计准则</p><pre><code>  例如“GRASP”模式集。
</code></pre><p>−针对更具体但常见的上下文/问题的设计模式。</p><pre><code>  例如“观察员”
  
  通常足够具体，以包括大纲解决方案的UML模型。
</code></pre></li></ul><h3 id="_3-1-grasp" tabindex="-1"><a class="header-anchor" href="#_3-1-grasp"><span>3.1 <strong>GRASP</strong></span></a></h3><p>General, Responsibility, Assignment, Software, Patterns</p><figure><img src="`+O+'" alt="image-20240424022601361" tabindex="0" loading="lazy"><figcaption>image-20240424022601361</figcaption></figure><h4 id="_3-1-1-controller" tabindex="-1"><a class="header-anchor" href="#_3-1-1-controller"><span>3.1.1 Controller</span></a></h4><ul><li><p>Problem: Who should be responsible for handling a system event or business logic?</p><p>− System event examples: an external input event, e.g., a cashier scans an item to register a sale or ‘performing a sell check’, when pressing the spell check button in a word processor</p></li><li><p>Solution: Assign responsibility for handling a system event message to a class</p></li></ul><p>专门处理逻辑操作的模块。图示如下：</p><figure><img src="'+P+'" alt="image-20240424023245910" tabindex="0" loading="lazy"><figcaption>image-20240424023245910</figcaption></figure><h4 id="_3-1-2-polymorphism-多态性" tabindex="-1"><a class="header-anchor" href="#_3-1-2-polymorphism-多态性"><span>3.1.2 Polymorphism 多态性</span></a></h4><ul><li>Problem: How to handle alternative behaviour that depends on type? How to create pluggable software components?</li><li>Solution: Assign responsibility for the alternative behaviour – using polymorphic operations – to the types for which the behaviour varies.</li></ul><p>继承？子类和父类</p><img src="'+j+'" alt="image-20240424025011384" style="zoom:80%;"><figure><img src="'+z+'" alt="image-20240424030426766" tabindex="0" loading="lazy"><figcaption>image-20240424030426766</figcaption></figure><p>Actual Solution: Make each type a subclass of Payment. Payment will have an operation “calPayment”.</p><p>– In subclass Credit Card, to override/redefine the above inherited operation to define how it is calculated for credit card payment （这里是Credit Card覆盖了父类的方法，创建了自己独特的方法。）</p><p>– In Cash to reflect how it is done for cash payment. So, there is no need to check what type of Payment it is every time.</p><p>– if an Credit Card object is called, then the ‘calPayment’ method will be executed with a 5% charge</p><p>– if an Cash object is called, then the ‘calPayment’ method will be executed without any charge</p><h3 id="_3-2-gof-patterns" tabindex="-1"><a class="header-anchor" href="#_3-2-gof-patterns"><span>3.2 GoF Patterns</span></a></h3><p>‘Gang of Four’ (GOF, Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides) analysed 23 Design patterns which provide solutions to general problems faced during software development as follows:</p><p>− Creational patterns - manage the creation of objects</p><p>− Structural patterns - describe how objects are connected together to form more complex objects</p><p>− Behavioural patterns - describe how code is organized, to assign responsibility or roles to certain classes, and to specify the way objects communicate with each other</p><figure><img src="'+D+'" alt="image-20240424032047929" tabindex="0" loading="lazy"><figcaption>image-20240424032047929</figcaption></figure>',127),T=[q];function I(G,M){return a(),i("div",null,T)}const H=e(A,[["render",I],["__file","OO_principle.html.vue"]]),R=JSON.parse('{"path":"/zh/Software_Design/OO_principle.html","title":"OO principle","lang":"zh-CN","frontmatter":{"title":"OO principle","icon":"c","date":"2024-04-23T02:45:25.000Z","author":"XiaoXianYue","isOriginal":true,"category":["Python","大二下"],"tag":["Python","大二下"],"sticky":false,"star":false,"article":true,"timeline":true,"image":false,"navbar":true,"sidebarIcon":true,"headerDepth":5,"lastUpdated":true,"editLink":false,"backToTop":true,"toc":true,"description":"1. OO Software Design Concepts image-20240423102031569 1.1 Abstraction Data abstraction: The developer and other objects in the system have a high level summary view (an abstrac...","head":[["meta",{"property":"og:url","content":"https://bougiemoonintaurus/zh/Software_Design/OO_principle.html"}],["meta",{"property":"og:site_name","content":"奶酪奶酪"}],["meta",{"property":"og:title","content":"OO principle"}],["meta",{"property":"og:description","content":"1. OO Software Design Concepts image-20240423102031569 1.1 Abstraction Data abstraction: The developer and other objects in the system have a high level summary view (an abstrac..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-09T17:01:37.000Z"}],["meta",{"property":"article:author","content":"XiaoXianYue"}],["meta",{"property":"article:tag","content":"Python"}],["meta",{"property":"article:tag","content":"大二下"}],["meta",{"property":"article:published_time","content":"2024-04-23T02:45:25.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-09T17:01:37.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"OO principle\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-04-23T02:45:25.000Z\\",\\"dateModified\\":\\"2024-05-09T17:01:37.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"XiaoXianYue\\"}]}"]]},"headers":[{"level":2,"title":"1. OO Software Design Concepts","slug":"_1-oo-software-design-concepts","link":"#_1-oo-software-design-concepts","children":[{"level":3,"title":"1.1 Abstraction","slug":"_1-1-abstraction","link":"#_1-1-abstraction","children":[]},{"level":3,"title":"1.2 Encapsulation","slug":"_1-2-encapsulation","link":"#_1-2-encapsulation","children":[{"level":4,"title":"1.2.1 Class/Object","slug":"_1-2-1-class-object","link":"#_1-2-1-class-object","children":[]},{"level":4,"title":"1.2.2 Aggregation/Composition","slug":"_1-2-2-aggregation-composition","link":"#_1-2-2-aggregation-composition","children":[]}]},{"level":3,"title":"1.3 Information Hiding","slug":"_1-3-information-hiding","link":"#_1-3-information-hiding","children":[]},{"level":3,"title":"1.4  Separation of Concerns & Modularity","slug":"_1-4-separation-of-concerns-modularity","link":"#_1-4-separation-of-concerns-modularity","children":[{"level":4,"title":"1.4.1 Cohesion","slug":"_1-4-1-cohesion","link":"#_1-4-1-cohesion","children":[]},{"level":4,"title":"1.4.2 Coupling","slug":"_1-4-2-coupling","link":"#_1-4-2-coupling","children":[]}]},{"level":3,"title":"1.5  Reusability","slug":"_1-5-reusability","link":"#_1-5-reusability","children":[{"level":4,"title":"1.5.1 Aggregation and composition","slug":"_1-5-1-aggregation-and-composition","link":"#_1-5-1-aggregation-and-composition","children":[]},{"level":4,"title":"1.5.2  Generalisation/Specialisation (Inheritance)","slug":"_1-5-2-generalisation-specialisation-inheritance","link":"#_1-5-2-generalisation-specialisation-inheritance","children":[]},{"level":4,"title":"1.5.3 Example","slug":"_1-5-3-example","link":"#_1-5-3-example","children":[]}]}]},{"level":2,"title":"2. Design principle","slug":"_2-design-principle","link":"#_2-design-principle","children":[{"level":3,"title":"2.1  Open-Closed","slug":"_2-1-open-closed","link":"#_2-1-open-closed","children":[]}]},{"level":2,"title":"3.  Design pattern","slug":"_3-design-pattern","link":"#_3-design-pattern","children":[{"level":3,"title":"3.1 GRASP","slug":"_3-1-grasp","link":"#_3-1-grasp","children":[{"level":4,"title":"3.1.1 Controller","slug":"_3-1-1-controller","link":"#_3-1-1-controller","children":[]},{"level":4,"title":"3.1.2 Polymorphism 多态性","slug":"_3-1-2-polymorphism-多态性","link":"#_3-1-2-polymorphism-多态性","children":[]}]},{"level":3,"title":"3.2 GoF Patterns","slug":"_3-2-gof-patterns","link":"#_3-2-gof-patterns","children":[]}]}],"git":{"createdTime":1701251856000,"updatedTime":1715274097000,"contributors":[{"name":"Xiaoxianyue","email":"2310219843@qq.com","commits":5}]},"readingTime":{"minutes":6.28,"words":1884},"filePathRelative":"zh/Software_Design/OO_principle.md","localizedDate":"2024年4月23日","excerpt":"<h2>1. OO Software Design Concepts</h2>\\n\\n<h3>1.1 Abstraction</h3>\\n<ul>\\n<li>Data abstraction:  The  developer and other objects in  the system have a high level  summary view (an abstract  view) of what data items are.  It contains the required information  about an object.</li>\\n<li>Procedure abstraction:  A high level summary view  of the operations provided.   The details and how the  methods are coded are  ignored.</li>\\n</ul>","autoDesc":true}');export{H as comp,R as data};
