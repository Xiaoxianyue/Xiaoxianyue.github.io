import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,b as p,a as s,d as a,o as e}from"./app-84lBMjzT.js";const t={},i={class:"MathJax",jax:"SVG",style:{position:"relative"}},r={style:{"vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"11.03ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 4875.2 1000","aria-hidden":"true"},c={class:"MathJax",jax:"SVG",style:{position:"relative"}},F={style:{"vertical-align":"-0.05ex"},xmlns:"http://www.w3.org/2000/svg",width:"1.74ex",height:"1.595ex",role:"img",focusable:"false",viewBox:"0 -683 769 705","aria-hidden":"true"},d={class:"MathJax",jax:"SVG",style:{position:"relative"}},y={style:{"vertical-align":"0"},xmlns:"http://www.w3.org/2000/svg",width:"1.729ex",height:"1.538ex",role:"img",focusable:"false",viewBox:"0 -680 764 680","aria-hidden":"true"},m={class:"MathJax",jax:"SVG",style:{position:"relative"}},Q={style:{"vertical-align":"-0.025ex"},xmlns:"http://www.w3.org/2000/svg",width:"1.62ex",height:"1.027ex",role:"img",focusable:"false",viewBox:"0 -443 716 454","aria-hidden":"true"},v={class:"MathJax",jax:"SVG",style:{position:"relative"}},u={style:{"vertical-align":"-0.375ex"},xmlns:"http://www.w3.org/2000/svg",width:"2.085ex",height:"1.377ex",role:"img",focusable:"false",viewBox:"0 -443 921.6 608.6","aria-hidden":"true"},T={class:"MathJax",jax:"SVG",style:{position:"relative"}},h={style:{"vertical-align":"-0.566ex"},xmlns:"http://www.w3.org/2000/svg",width:"20.031ex",height:"2.262ex",role:"img",focusable:"false",viewBox:"0 -750 8853.8 1000","aria-hidden":"true"},g={class:"MathJax",jax:"SVG",style:{position:"relative"}},b={style:{"vertical-align":"0"},xmlns:"http://www.w3.org/2000/svg",width:"1.729ex",height:"1.538ex",role:"img",focusable:"false",viewBox:"0 -680 764 680","aria-hidden":"true"},E={class:"MathJax",jax:"SVG",style:{position:"relative"}},D={style:{"vertical-align":"-0.05ex"},xmlns:"http://www.w3.org/2000/svg",width:"1.74ex",height:"1.595ex",role:"img",focusable:"false",viewBox:"0 -683 769 705","aria-hidden":"true"},f={class:"MathJax",jax:"SVG",style:{position:"relative"}},B={style:{"vertical-align":"-0.025ex"},xmlns:"http://www.w3.org/2000/svg",width:"1.448ex",height:"1.025ex",role:"img",focusable:"false",viewBox:"0 -442 640 453","aria-hidden":"true"};function A(x,n){return e(),l("div",null,[n[33]||(n[33]=p(`<h2 id="_1-dijkstra-s-algorithm" tabindex="-1"><a class="header-anchor" href="#_1-dijkstra-s-algorithm"><span>1. Dijkstra’s algorithm</span></a></h2><p>算法目标和使用场景<br> 使用 Dijkstra 算法,可以寻找图中节点之间的最短路径。特别是,可以在图中寻找一个节点（称为“源节点”）到所有其它节点的最短路径,生成一个最短路径树。</p><p>GPS 设备使用这个算法来寻找当前位置到目标位置的最短路径。Dijkstra 算法被广泛应用在工业上,尤其是需要建模网络的领域。</p><h3 id="_1-1-基础知识" tabindex="-1"><a class="header-anchor" href="#_1-1-基础知识"><span>1.1 基础知识</span></a></h3><ol><li>Dijkstra‘s 算法从指定的节点（源节点）出发,寻找它与图中所有其他节点之间的最短路径。</li><li>Dijkstra’s 算法会记录当前已知最短路径,并在寻找更短的路径时更新。</li><li>一旦找到源节点与其他节点之间的最短路径,那个节点会被标记为“已访问”并添加到路径中。</li><li>重复寻找过程,直到图中所有节点都已经添加到路径中,这样就可以得到从源节点出发访问所有其他节点的最短路径方案。</li></ol><p>必要条件：</p><p>Dijkstra’s 只能用在权重为正的图中,因为计算过程中需要权重相加来寻找最短路径。</p><p>如果图中有负权重的边,这个算法就无法正常工作。</p><p>一旦一个节点被标记为已访问,当前访问它的路径就被标记为访问它的最小路径。</p><p>如果存在负权重,则可能在之后的计算中得到总权重更小的路径,从而影响之前的结果（TIPs：即可能出现多绕路反而路线更短的情况,不合实际）</p><h3 id="_1-2-完整代码" tabindex="-1"><a class="header-anchor" href="#_1-2-完整代码"><span>1.2 完整代码</span></a></h3><div class="language-python line-numbers-mode has-collapsed-lines collapsed" data-highlighter="shiki" data-ext="python" style="--vp-collapsed-lines:15;background-color:#272822;color:#F8F8F2;"><pre class="shiki monokai vp-code"><code><span class="line"><span style="color:#F92672;">import</span><span style="color:#F8F8F2;"> heapq</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">def</span><span style="color:#A6E22E;"> dijkstra</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">graph</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">start</span><span style="color:#F8F8F2;">):</span></span>
<span class="line"><span style="color:#88846F;">    # 初始化距离表,将所有节点的初始距离设为无限大</span></span>
<span class="line"><span style="color:#88846F;">    # 意思是开始时假定所有节点都不可达</span></span>
<span class="line"><span style="color:#F8F8F2;">    distances </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> {node: </span><span style="color:#66D9EF;font-style:italic;">float</span><span style="color:#F8F8F2;">(</span><span style="color:#E6DB74;">&#39;inf&#39;</span><span style="color:#F8F8F2;">) </span><span style="color:#F92672;">for</span><span style="color:#F8F8F2;"> node </span><span style="color:#F92672;">in</span><span style="color:#F8F8F2;"> graph}</span></span>
<span class="line"><span style="color:#F8F8F2;">    distances[start] </span><span style="color:#F92672;">=</span><span style="color:#AE81FF;"> 0</span><span style="color:#88846F;">  # 起始点回到自身的距离为0</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">    # 创建一个优先级队列,存放待处理的点</span></span>
<span class="line"><span style="color:#F8F8F2;">    priority_queue </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> [(</span><span style="color:#AE81FF;">0</span><span style="color:#F8F8F2;">, start)]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">    # 循环处理优先级队列中的节点</span></span>
<span class="line"><span style="color:#F92672;">    while</span><span style="color:#F8F8F2;"> priority_queue:</span></span>
<span class="line"><span style="color:#88846F;">        # 弹出距离最小的节点</span></span>
<span class="line"><span style="color:#F8F8F2;">        current_distance, current_node </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> heapq.heappop(priority_queue)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">        # 如果弹出的节点距离大于已知最短距离,则跳过该节点（已经找到更短路径）</span></span>
<span class="line"><span style="color:#F92672;">        if</span><span style="color:#F8F8F2;"> current_distance </span><span style="color:#F92672;">&gt;</span><span style="color:#F8F8F2;"> distances[current_node]:</span></span>
<span class="line"><span style="color:#F92672;">            continue</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">        # 遍历当前节点的所有邻居节点</span></span>
<span class="line"><span style="color:#F92672;">        for</span><span style="color:#F8F8F2;"> neighbor, weight </span><span style="color:#F92672;">in</span><span style="color:#F8F8F2;"> graph[current_node].items():</span></span>
<span class="line"><span style="color:#88846F;">            # 计算从当前节点到邻居节点的距离</span></span>
<span class="line"><span style="color:#F8F8F2;">            distance </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> current_distance </span><span style="color:#F92672;">+</span><span style="color:#F8F8F2;"> weight</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">            # 如果找到到达邻居节点的更短路径,更新距离表</span></span>
<span class="line"><span style="color:#F92672;">            if</span><span style="color:#F8F8F2;"> distance </span><span style="color:#F92672;">&lt;</span><span style="color:#F8F8F2;"> distances[neighbor]:</span></span>
<span class="line"><span style="color:#F8F8F2;">                distances[neighbor] </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> distance  </span><span style="color:#88846F;"># 更新距离表</span></span>
<span class="line"><span style="color:#88846F;">                # 将邻居节点和新的距离加入优先队列</span></span>
<span class="line"><span style="color:#F8F8F2;">                heapq.heappush(priority_queue, (distance, neighbor))</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">        # 返回从起点到各节点的最短距离</span></span>
<span class="line"><span style="color:#F92672;">    return</span><span style="color:#F8F8F2;"> distances</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;"># 示例图</span></span>
<span class="line"><span style="color:#F8F8F2;">graph </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> {</span></span>
<span class="line"><span style="color:#E6DB74;">    &#39;A&#39;</span><span style="color:#F8F8F2;">: {</span><span style="color:#E6DB74;">&#39;B&#39;</span><span style="color:#F8F8F2;">: </span><span style="color:#AE81FF;">1</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&#39;C&#39;</span><span style="color:#F8F8F2;">: </span><span style="color:#AE81FF;">4</span><span style="color:#F8F8F2;">},</span></span>
<span class="line"><span style="color:#E6DB74;">    &#39;B&#39;</span><span style="color:#F8F8F2;">: {</span><span style="color:#E6DB74;">&#39;A&#39;</span><span style="color:#F8F8F2;">: </span><span style="color:#AE81FF;">1</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&#39;C&#39;</span><span style="color:#F8F8F2;">: </span><span style="color:#AE81FF;">2</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&#39;D&#39;</span><span style="color:#F8F8F2;">: </span><span style="color:#AE81FF;">5</span><span style="color:#F8F8F2;">},</span></span>
<span class="line"><span style="color:#E6DB74;">    &#39;C&#39;</span><span style="color:#F8F8F2;">: {</span><span style="color:#E6DB74;">&#39;A&#39;</span><span style="color:#F8F8F2;">: </span><span style="color:#AE81FF;">4</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&#39;B&#39;</span><span style="color:#F8F8F2;">: </span><span style="color:#AE81FF;">2</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&#39;D&#39;</span><span style="color:#F8F8F2;">: </span><span style="color:#AE81FF;">1</span><span style="color:#F8F8F2;">},</span></span>
<span class="line"><span style="color:#E6DB74;">    &#39;D&#39;</span><span style="color:#F8F8F2;">: {</span><span style="color:#E6DB74;">&#39;B&#39;</span><span style="color:#F8F8F2;">: </span><span style="color:#AE81FF;">5</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&#39;C&#39;</span><span style="color:#F8F8F2;">: </span><span style="color:#AE81FF;">1</span><span style="color:#F8F8F2;">}</span></span>
<span class="line"><span style="color:#F8F8F2;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;"># 从起点A运行 Dikjkatra 算法,计算到所有其他节点的最短路径</span></span>
<span class="line"><span style="color:#F8F8F2;">start_node </span><span style="color:#F92672;">=</span><span style="color:#E6DB74;"> &#39;A&#39;</span></span>
<span class="line"><span style="color:#F8F8F2;">shortest_path </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> dijkstra(graph, start_node)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;"># 输出从起点到其他所有结点的最短距离</span></span>
<span class="line"><span style="color:#66D9EF;">print</span><span style="color:#F8F8F2;">(</span><span style="color:#66D9EF;font-style:italic;">f</span><span style="color:#E6DB74;">&#39;从节点</span><span style="color:#AE81FF;">{</span><span style="color:#F8F8F2;">start_node</span><span style="color:#AE81FF;">}</span><span style="color:#E6DB74;">到其他节点的最短距离为：&#39;</span><span style="color:#F8F8F2;">)</span></span>
<span class="line"><span style="color:#F92672;">for</span><span style="color:#F8F8F2;"> node, distance </span><span style="color:#F92672;">in</span><span style="color:#F8F8F2;"> shortest_path.items():</span></span>
<span class="line"><span style="color:#66D9EF;">    print</span><span style="color:#F8F8F2;">(</span><span style="color:#66D9EF;font-style:italic;">f</span><span style="color:#E6DB74;">&quot;</span><span style="color:#AE81FF;">{</span><span style="color:#F8F8F2;">start_node</span><span style="color:#AE81FF;">}</span><span style="color:#E6DB74;">-&gt;</span><span style="color:#AE81FF;">{</span><span style="color:#F8F8F2;">node</span><span style="color:#AE81FF;">}</span><span style="color:#E6DB74;">: </span><span style="color:#AE81FF;">{</span><span style="color:#F8F8F2;">distance</span><span style="color:#AE81FF;">}</span><span style="color:#E6DB74;">&quot;</span><span style="color:#F8F8F2;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="collapsed-lines"></div></div><h2 id="_2-prim-s-algorithm" tabindex="-1"><a class="header-anchor" href="#_2-prim-s-algorithm"><span>2. Prim’s algorithm</span></a></h2><p>prim’s algorithm 是一个常用的最小生成树算法。</p><h3 id="_2-1-什么是生成树" tabindex="-1"><a class="header-anchor" href="#_2-1-什么是生成树"><span>2.1 什么是生成树？</span></a></h3><p>在图论中,一个生成树是包含了图中所有顶点并连接在一起的子图。最小生成树（Minimum Spanning Tree）是一种生成树,且它的边的权值总和最小。简单来说,最小生成树是找到连接所有节点的最低成本路径。</p><p>举个例子：假设我们有一些城市,城市之间有道路连接,每条路的建设成本不同。我们希望以最小的建设成本连接所有城市,这时就可以用最小生成树算法来找到最低成本的连接方案。</p><h3 id="_2-2-prim-s-algorithm-是什么" tabindex="-1"><a class="header-anchor" href="#_2-2-prim-s-algorithm-是什么"><span>2.2 Prim&#39;s algorithm 是什么？</span></a></h3><p>Prim&#39;s 算法是一种贪心算法,用来求解加权无向连接图的最小生成树。Prim‘s 算法每次都从已经连接的节点中选择一条最短的边来进行扩张,直到所有节点都被包括在内。</p><h3 id="_2-3-prim-s-算法的基本思想" tabindex="-1"><a class="header-anchor" href="#_2-3-prim-s-算法的基本思想"><span>2.3 Prim&#39;s 算法的基本思想</span></a></h3><ul><li>开始,选择一个起点,并把它加入到生成树当中</li><li>逐步扩展：每次从当前生成树中找出一个连接到树外界点的权重边,将该边和该节点加入生成树。</li><li>重复这个过程,直到所有节点都加入到生成树中。</li></ul><h3 id="_2-4-prim-算法的步骤" tabindex="-1"><a class="header-anchor" href="#_2-4-prim-算法的步骤"><span>2.4 Prim 算法的步骤</span></a></h3>`,22)),s("p",null,[n[8]||(n[8]=a("假设我们有一个图 ")),s("mjx-container",i,[(e(),l("svg",r,n[0]||(n[0]=[p('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path></g><g data-mml-node="mo" transform="translate(1063.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mo" transform="translate(2119.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(2508.6,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"></path></g><g data-mml-node="mo" transform="translate(3277.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(3722.2,0)"><path data-c="1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"></path></g><g data-mml-node="mo" transform="translate(4486.2,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g>',1)]))),n[1]||(n[1]=s("mjx-assistive-mml",{unselectable:"on",display:"inline"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("mi",null,"G"),s("mo",null,"="),s("mo",{stretchy:"false"},"("),s("mi",null,"V"),s("mo",null,","),s("mi",null,"E"),s("mo",{stretchy:"false"},")")])],-1))]),n[9]||(n[9]=a(",其中 ")),s("mjx-container",c,[(e(),l("svg",F,n[2]||(n[2]=[s("g",{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"scale(1,-1)"},[s("g",{"data-mml-node":"math"},[s("g",{"data-mml-node":"mi"},[s("path",{"data-c":"1D449",d:"M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"})])])],-1)]))),n[3]||(n[3]=s("mjx-assistive-mml",{unselectable:"on",display:"inline"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("mi",null,"V")])],-1))]),n[10]||(n[10]=a(" 是节点集合,")),s("mjx-container",d,[(e(),l("svg",y,n[4]||(n[4]=[s("g",{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"scale(1,-1)"},[s("g",{"data-mml-node":"math"},[s("g",{"data-mml-node":"mi"},[s("path",{"data-c":"1D438",d:"M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"})])])],-1)]))),n[5]||(n[5]=s("mjx-assistive-mml",{unselectable:"on",display:"inline"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("mi",null,"E")])],-1))]),n[11]||(n[11]=a(" 是边集合,边的权重用 ")),s("mjx-container",m,[(e(),l("svg",Q,n[6]||(n[6]=[s("g",{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"scale(1,-1)"},[s("g",{"data-mml-node":"math"},[s("g",{"data-mml-node":"mi"},[s("path",{"data-c":"1D464",d:"M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z"})])])],-1)]))),n[7]||(n[7]=s("mjx-assistive-mml",{unselectable:"on",display:"inline"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("mi",null,"w")])],-1))]),n[12]||(n[12]=a(" 表示。"))]),s("ol",null,[s("li",null,[n[15]||(n[15]=s("strong",null,"初始化",-1)),n[16]||(n[16]=a("：从任意一个节点开始,记为节点 ")),s("mjx-container",v,[(e(),l("svg",u,n[13]||(n[13]=[p('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mn" transform="translate(518,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g>',1)]))),n[14]||(n[14]=s("mjx-assistive-mml",{unselectable:"on",display:"inline"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("msub",null,[s("mi",null,"v"),s("mn",null,"0")])])],-1))]),n[17]||(n[17]=a("。"))]),n[18]||(n[18]=s("li",null,[s("strong",null,"选择边"),a("：找到一个"),s("strong",null,"连接生成树"),a("和"),s("strong",null,"未连接节点"),a("的最小权重边,将该边和对应的节点加入生成树。")],-1)),n[19]||(n[19]=s("li",null,[s("strong",null,"重复选择"),a("：重复上一步,直到所有节点都在生成树中。")],-1))]),n[34]||(n[34]=p(`<h3 id="_2-5-举个例子" tabindex="-1"><a class="header-anchor" href="#_2-5-举个例子"><span>2.5 举个例子</span></a></h3><ul><li><p>Step 1：初始化</p><ul><li>起始节点,选择节点A ,加入生成树。</li><li>已加入节点：{A}</li><li>候选边： <ul><li>A – B(1) ;</li><li>A – C(3) ;</li><li>A – D(4)</li></ul></li></ul></li><li><p>Step 2：选择最小权重边</p><ul><li>从候选边中选择权重最小的边 A – B</li><li>加入生成树：边 A – B ；节点 B</li><li>已加入节点：{A, B}</li><li>更新后选边： <ul><li>A – C(3) ;</li><li>A – D(4) ;</li><li>B – C(2) ;</li><li>B – D(5) ;</li></ul></li></ul></li><li><p>Step 3：继续选择最小边</p><ul><li>选择权重最小的候选边：B – C</li><li>加入最小生成树：边 B – C；节点 C</li><li>已加入的节点：{A,B,C}</li><li>更新后的选边 <ul><li>C – D(6) ;</li><li>A – D(4) ;</li><li>B – D(5) ;</li></ul></li></ul></li><li><p>Step 4 :</p><ul><li>选择权重最小的边 A – D</li><li>加入最小生成树：边 A – D；节点 D</li><li>已加入的节点：{A, B,C,D}</li><li>所有节点都加入,结束。</li></ul></li><li><p>总结：</p><p>现在最小生成树里的节点和边有：</p><ul><li>A – B 1</li><li>B – C 2</li><li>A – D 4</li><li>总长度：7</li></ul></li></ul><h3 id="_2-6-例子实现" tabindex="-1"><a class="header-anchor" href="#_2-6-例子实现"><span>2.6 例子实现</span></a></h3><div class="language-python line-numbers-mode has-collapsed-lines collapsed" data-highlighter="shiki" data-ext="python" style="--vp-collapsed-lines:15;background-color:#272822;color:#F8F8F2;"><pre class="shiki monokai vp-code"><code><span class="line"><span style="color:#88846F;"># 导入 heapq 模块,用于实现最小堆（优先队列）</span></span>
<span class="line"><span style="color:#F92672;">import</span><span style="color:#F8F8F2;"> heapq</span></span>
<span class="line"></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">def</span><span style="color:#A6E22E;"> prim</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">graph</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">start</span><span style="color:#F8F8F2;">):</span></span>
<span class="line"><span style="color:#E6DB74;">    &quot;&quot;&quot;</span></span>
<span class="line"><span style="color:#E6DB74;">    使用 Prim 算法计算最小生成树（MST）</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E6DB74;">    参数：</span></span>
<span class="line"><span style="color:#E6DB74;">    graph - 图的邻接表表示,格式为 {节点: [(邻居节点, 边的权重), ...]}</span></span>
<span class="line"><span style="color:#E6DB74;">    start - 起始节点</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E6DB74;">    返回：</span></span>
<span class="line"><span style="color:#E6DB74;">    mst - 最小生成树的边集合,格式为 [(节点1, 节点2, 权重), ...]</span></span>
<span class="line"><span style="color:#E6DB74;">    total_weight - 最小生成树的总权重</span></span>
<span class="line"><span style="color:#E6DB74;">    &quot;&quot;&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">    # 初始化最小生成树的边集合为空列表</span></span>
<span class="line"><span style="color:#F8F8F2;">    mst </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> []</span></span>
<span class="line"><span style="color:#88846F;">    # 初始化最小生成树的总权重为 0</span></span>
<span class="line"><span style="color:#F8F8F2;">    total_weight </span><span style="color:#F92672;">=</span><span style="color:#AE81FF;"> 0</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">    # 创建一个集合来存储已访问过的节点,初始时只包含起始节点</span></span>
<span class="line"><span style="color:#F8F8F2;">    visited </span><span style="color:#F92672;">=</span><span style="color:#66D9EF;font-style:italic;"> set</span><span style="color:#F8F8F2;">([start])</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">    # 创建一个最小堆（优先队列）来存储候选边,初始为空</span></span>
<span class="line"><span style="color:#F8F8F2;">    min_heap </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> []</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">    # 将起始节点的所有边加入最小堆</span></span>
<span class="line"><span style="color:#88846F;">    # 遍历起始节点的所有邻居节点</span></span>
<span class="line"><span style="color:#F92672;">    for</span><span style="color:#F8F8F2;"> neighbor, weight </span><span style="color:#F92672;">in</span><span style="color:#F8F8F2;"> graph[start]:</span></span>
<span class="line"><span style="color:#88846F;">        # 将边的信息作为元组 (权重, 起始节点, 目标节点) 加入最小堆</span></span>
<span class="line"><span style="color:#F8F8F2;">        heapq.heappush(min_heap, (weight,start, neighbor))</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">    # 当最小堆不为空时,继续循环</span></span>
<span class="line"><span style="color:#F92672;">    while</span><span style="color:#F8F8F2;"> min_heap:</span></span>
<span class="line"><span style="color:#88846F;">        # 从最小堆中弹出权重最小的边</span></span>
<span class="line"><span style="color:#F8F8F2;">        weight, frm, to </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> heapq.heappop(min_heap)</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">        # 如果目标节点已经被访问过,跳过该边（避免形成环）</span></span>
<span class="line"><span style="color:#F92672;">        if</span><span style="color:#F8F8F2;"> to </span><span style="color:#F92672;">in</span><span style="color:#F8F8F2;"> visited:</span></span>
<span class="line"><span style="color:#F92672;">            continue</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">        # 将该边加入最小生成树的边集合</span></span>
<span class="line"><span style="color:#F8F8F2;">        mst.append((frm, to, weight))</span></span>
<span class="line"><span style="color:#88846F;">        # 更新最小生成树的总权重</span></span>
<span class="line"><span style="color:#F8F8F2;">        total_weight </span><span style="color:#F92672;">+=</span><span style="color:#F8F8F2;"> weight</span></span>
<span class="line"><span style="color:#88846F;">        # 将目标节点标记为已访问</span></span>
<span class="line"><span style="color:#F8F8F2;">        visited.add(to)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">        # 遍历目标节点的所有邻居节点</span></span>
<span class="line"><span style="color:#F92672;">        for</span><span style="color:#F8F8F2;"> neighbor, w </span><span style="color:#F92672;">in</span><span style="color:#F8F8F2;"> graph[to]:</span></span>
<span class="line"><span style="color:#88846F;">            # 如果邻居节点未被访问过,将边加入最小堆</span></span>
<span class="line"><span style="color:#F92672;">            if</span><span style="color:#F8F8F2;"> neighbor </span><span style="color:#F92672;">not</span><span style="color:#F92672;"> in</span><span style="color:#F8F8F2;"> visited:</span></span>
<span class="line"><span style="color:#F8F8F2;">                heapq.heappush(min_heap, (w, to, neighbor))</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">    # 返回最小生成树的边集合和总权重</span></span>
<span class="line"><span style="color:#F92672;">    return</span><span style="color:#F8F8F2;"> mst, total_weight</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;"># 测试代码</span></span>
<span class="line"><span style="color:#F92672;">if</span><span style="color:#F8F8F2;"> __name__ </span><span style="color:#F92672;">==</span><span style="color:#E6DB74;"> &quot;__main__&quot;</span><span style="color:#F8F8F2;">:</span></span>
<span class="line"><span style="color:#88846F;">    # 定义图,使用邻接表表示,每个节点对应一个列表,列表中包含其邻居节点和边的权重</span></span>
<span class="line"><span style="color:#F8F8F2;">    graph </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> {</span></span>
<span class="line"><span style="color:#E6DB74;">        &#39;A&#39;</span><span style="color:#F8F8F2;">: [(</span><span style="color:#E6DB74;">&#39;B&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">1</span><span style="color:#F8F8F2;">), (</span><span style="color:#E6DB74;">&#39;C&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">3</span><span style="color:#F8F8F2;">), (</span><span style="color:#E6DB74;">&#39;D&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">4</span><span style="color:#F8F8F2;">)],</span></span>
<span class="line"><span style="color:#E6DB74;">        &#39;B&#39;</span><span style="color:#F8F8F2;">: [(</span><span style="color:#E6DB74;">&#39;A&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">1</span><span style="color:#F8F8F2;">), (</span><span style="color:#E6DB74;">&#39;C&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">2</span><span style="color:#F8F8F2;">), (</span><span style="color:#E6DB74;">&#39;D&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">5</span><span style="color:#F8F8F2;">)],</span></span>
<span class="line"><span style="color:#E6DB74;">        &#39;C&#39;</span><span style="color:#F8F8F2;">: [(</span><span style="color:#E6DB74;">&#39;A&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">3</span><span style="color:#F8F8F2;">), (</span><span style="color:#E6DB74;">&#39;B&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">2</span><span style="color:#F8F8F2;">), (</span><span style="color:#E6DB74;">&#39;D&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">6</span><span style="color:#F8F8F2;">)],</span></span>
<span class="line"><span style="color:#E6DB74;">        &#39;D&#39;</span><span style="color:#F8F8F2;">: [(</span><span style="color:#E6DB74;">&#39;A&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">4</span><span style="color:#F8F8F2;">), (</span><span style="color:#E6DB74;">&#39;B&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">5</span><span style="color:#F8F8F2;">), (</span><span style="color:#E6DB74;">&#39;C&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">6</span><span style="color:#F8F8F2;">)],</span></span>
<span class="line"><span style="color:#F8F8F2;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">    # 调用 prim 函数,指定起始节点为 &#39;A&#39;</span></span>
<span class="line"><span style="color:#F8F8F2;">    mst, total_weight </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> prim(graph, </span><span style="color:#E6DB74;">&#39;A&#39;</span><span style="color:#F8F8F2;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">    # 输出最小生成树的边</span></span>
<span class="line"><span style="color:#66D9EF;">    print</span><span style="color:#F8F8F2;">(</span><span style="color:#E6DB74;">&quot;最小生成树的边：&quot;</span><span style="color:#F8F8F2;">)</span></span>
<span class="line"><span style="color:#88846F;">    # 遍历最小生成树的边集合</span></span>
<span class="line"><span style="color:#F92672;">    for</span><span style="color:#F8F8F2;"> edge </span><span style="color:#F92672;">in</span><span style="color:#F8F8F2;"> mst:</span></span>
<span class="line"><span style="color:#88846F;">        # edge 是一个包含 (起始节点, 目标节点, 权重) 的元组</span></span>
<span class="line"><span style="color:#66D9EF;">        print</span><span style="color:#F8F8F2;">(</span><span style="color:#66D9EF;font-style:italic;">f</span><span style="color:#E6DB74;">&quot;</span><span style="color:#AE81FF;">{</span><span style="color:#F8F8F2;">edge[</span><span style="color:#AE81FF;">0</span><span style="color:#F8F8F2;">]</span><span style="color:#AE81FF;">}</span><span style="color:#E6DB74;"> - </span><span style="color:#AE81FF;">{</span><span style="color:#F8F8F2;">edge[</span><span style="color:#AE81FF;">1</span><span style="color:#F8F8F2;">]</span><span style="color:#AE81FF;">}</span><span style="color:#E6DB74;"> 权重: </span><span style="color:#AE81FF;">{</span><span style="color:#F8F8F2;">edge[</span><span style="color:#AE81FF;">2</span><span style="color:#F8F8F2;">]</span><span style="color:#AE81FF;">}</span><span style="color:#E6DB74;">&quot;</span><span style="color:#F8F8F2;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">    # 输出最小生成树的总权重</span></span>
<span class="line"><span style="color:#66D9EF;">    print</span><span style="color:#F8F8F2;">(</span><span style="color:#66D9EF;font-style:italic;">f</span><span style="color:#E6DB74;">&quot;最小生成树的总权重: </span><span style="color:#AE81FF;">{</span><span style="color:#F8F8F2;">total_weight</span><span style="color:#AE81FF;">}</span><span style="color:#E6DB74;">&quot;</span><span style="color:#F8F8F2;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="collapsed-lines"></div></div><h2 id="_3-kruskal-算法" tabindex="-1"><a class="header-anchor" href="#_3-kruskal-算法"><span>3. Kruskal 算法</span></a></h2><p>最小生成树算法（MST）贪心算法。简单来说,最小生成树就是一个连接所有顶点的无环子图,且边的权重和最小。</p><h3 id="_3-1-基本步骤" tabindex="-1"><a class="header-anchor" href="#_3-1-基本步骤"><span>3.1 基本步骤</span></a></h3><ol><li>对边排序：将图中所有边按权重（比如：距离,费用）从小到大排序</li><li>初始化一个森林：每个顶点看作一个单独的集合（森林）</li><li>逐条添加边：从最小权重的边开始,依次尝试加入生成树中。 <ul><li>如果假如这条边不会形成环,就把他加入生成树</li><li>如果加入这条边会形成环,就跳过他</li></ul></li><li>重复步骤 3 ,直到生成树中 n - 1 条边（n 为图中顶点数）</li></ol><p>最终结果是包含所有顶点,权重和最小的生成树。</p><p>步骤详细解：</p><ul><li><p>第一步,对边排序</p><p>首先,将所有边按大小排序,这一步可以帮助我们找到权重最小的边,举一个例子：</p><ul><li>边（A,B）,权重 3</li><li>边（B,C）,权重 1</li><li>边（A,C）,权重 2</li><li>我们按权重大小排序 （B,C） （A,C） （A,B）</li></ul></li><li><p>第二步,初始化森林</p><p>假设图中有三个顶点 A,B,C。我们开始时将每个顶点当作一个单独的集合,也就是说现在有三个集合{A}, {B}, {C}.</p></li><li><p>第三步,逐步添加边</p><ol><li>选择权重最小的边 （B,C） <ul><li>检查这条边是否会形成环。因为 B 和 C 属于不同的集合,所以不会形成环,可以加入生成树</li><li>将 B 和 C 合并到一个集合里,更新森林为 {B,C} 和 {A}。</li></ul></li><li>选取下一个最小边（A,C）,权重 2 <ul><li>检查添加边是否会形成环,因为 A 和 C 属于不同的集合,所以不会形成环,可以加入生成树。</li><li>将 A 集合加入,更新森林为 {A,B,C}</li></ul></li><li>继续选择下一条边（A,B）,权重3 <ul><li>检查 A 和 B 是否在同一个集合里,此时 A,B 同在集合{A,B,C} 里,因此加入这条边会形成环,不可加入。</li></ul></li></ol></li></ul><h3 id="_3-2-kruskal-算法的关键概念" tabindex="-1"><a class="header-anchor" href="#_3-2-kruskal-算法的关键概念"><span>3.2 Kruskal 算法的关键概念</span></a></h3><ul><li><strong>并查集（Union-Find）</strong>：用于跟踪顶点属于哪个集合,并帮助检测是否形成环。这个数据结构可以让合并集合和查找集合变得快速高效。</li><li><strong>贪心策略</strong>：Kruskal 算法选择权重最小的边开始添加,这是贪心算法的一种特性。它保证每一步都选择当前最优的边,从而达到全局最优。</li></ul><h3 id="_3-3-kruskal-算法的复杂度" tabindex="-1"><a class="header-anchor" href="#_3-3-kruskal-算法的复杂度"><span>3.3 Kruskal 算法的复杂度</span></a></h3>`,14)),s("p",null,[n[28]||(n[28]=a("Kruskal 算法的时间复杂度取决于排序和并查集的操作,通常为 ")),s("mjx-container",T,[(e(),l("svg",h,n[20]||(n[20]=[p('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"></path></g><g data-mml-node="mi" transform="translate(2082.7,0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="mo" transform="translate(3360.7,0)"><path data-c="2061" d=""></path></g><g data-mml-node="mi" transform="translate(3527.3,0)"><path data-c="1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"></path></g><g data-mml-node="mo" transform="translate(4513.6,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(5513.8,0)"><path data-c="1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"></path></g><g data-mml-node="mi" transform="translate(6277.8,0)"><path data-c="1D6FC" d="M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z"></path></g><g data-mml-node="mo" transform="translate(6917.8,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(7306.8,0)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"></path></g><g data-mml-node="mo" transform="translate(8075.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(8464.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g>',1)]))),n[21]||(n[21]=s("mjx-assistive-mml",{unselectable:"on",display:"inline"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mi",null,"E"),s("mi",null,"log"),s("mo",{"data-mjx-texclass":"NONE"},"⁡"),s("mi",null,"E"),s("mo",null,"+"),s("mi",null,"E"),s("mi",null,"α"),s("mo",{stretchy:"false"},"("),s("mi",null,"V"),s("mo",{stretchy:"false"},")"),s("mo",{stretchy:"false"},")")])],-1))]),n[29]||(n[29]=a(",其中 ")),s("mjx-container",g,[(e(),l("svg",b,n[22]||(n[22]=[s("g",{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"scale(1,-1)"},[s("g",{"data-mml-node":"math"},[s("g",{"data-mml-node":"mi"},[s("path",{"data-c":"1D438",d:"M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"})])])],-1)]))),n[23]||(n[23]=s("mjx-assistive-mml",{unselectable:"on",display:"inline"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("mi",null,"E")])],-1))]),n[30]||(n[30]=a(" 是边的数量,")),s("mjx-container",E,[(e(),l("svg",D,n[24]||(n[24]=[s("g",{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"scale(1,-1)"},[s("g",{"data-mml-node":"math"},[s("g",{"data-mml-node":"mi"},[s("path",{"data-c":"1D449",d:"M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"})])])],-1)]))),n[25]||(n[25]=s("mjx-assistive-mml",{unselectable:"on",display:"inline"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("mi",null,"V")])],-1))]),n[31]||(n[31]=a(" 是顶点的数量,")),s("mjx-container",f,[(e(),l("svg",B,n[26]||(n[26]=[s("g",{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"scale(1,-1)"},[s("g",{"data-mml-node":"math"},[s("g",{"data-mml-node":"mi"},[s("path",{"data-c":"1D6FC",d:"M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z"})])])],-1)]))),n[27]||(n[27]=s("mjx-assistive-mml",{unselectable:"on",display:"inline"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("mi",null,"α")])],-1))]),n[32]||(n[32]=a(" 是极小的阿克曼函数,几乎可以视为常数。因此,Kruskal 算法适用于边较少的稀疏图。"))]),n[35]||(n[35]=p(`<p><strong>总结</strong>：Kruskal 算法通过逐步添加最小权重的边来构建最小生成树,确保不会形成环。</p><h3 id="_3-4-例子" tabindex="-1"><a class="header-anchor" href="#_3-4-例子"><span>3.4 例子</span></a></h3><p>边的表：</p><table><thead><tr><th>边</th><th>权重</th></tr></thead><tbody><tr><td>A — B</td><td>4</td></tr><tr><td>A — F</td><td>2</td></tr><tr><td>B — C</td><td>6</td></tr><tr><td>B — F</td><td>5</td></tr><tr><td>C — D</td><td>3</td></tr><tr><td>C — E</td><td>7</td></tr><tr><td>D — E</td><td>8</td></tr><tr><td>D — F</td><td>4</td></tr><tr><td>E — F</td><td>1</td></tr></tbody></table><ul><li><p>步骤 1 ：对所有边按照权重进行升序排序。</p><ul><li>E — F 1</li><li>A — F 2</li><li>C — D 3</li><li>A — B 4</li><li>D — F 4</li><li>B — F 5</li><li>B — C 6</li><li>C — E 7</li><li>D — E 8</li></ul></li><li><p>步骤 2：</p><p>把每个顶点放入单独的集合里。{A} {B} {C} {D} {E} {F}</p></li><li><p>步骤 3：</p><ol><li>E — F,权重 1,{E} 和 {F} 不在一个集合内。加入边,更新森林{E,F}</li><li>A — F,权重 2,{<strong>A</strong>} 和 {E,<strong>F</strong>} 显然不在一个集合。加入边,更新森林为{A,E,F}</li><li>C — D,权重 3,{C} 和 {D} 不在一个集合内。加入边,更新森林{C,D}</li><li>A — B,权重 4,{<strong>B</strong>} 和 {<strong>A</strong>,E,F} 不在一个集合内。加入边,更新森林{A,B,E,F}</li><li>D — F,权重 4,{C,<strong>D</strong>}和{A,B,E,<strong>F</strong>}不在一个集合内。加入边,更新森林为{A,B,C,D,E,F}</li><li>B — F,权重 5,{A,B,C,D,E,F},B 和 F 在同一个集合里,跳过边</li><li>B — C,权重 6,{A,B,C,D,E,F},B 和 C 在同一个集合里,跳过边</li><li>C — E,权重 7,{A,B,C,D,E,F},C 和 E 在同一个集合里,跳过边</li><li>D — E,权重 8,{A,B,C,D,E,F},D 和 E 在同一个集合里,跳过边</li></ol></li></ul><p>最后的生成树里的边有：{（E,F）,（A,F）,（C,D）,（A,B）,（D,F）},总权重为 14</p><h3 id="_3-5-代码" tabindex="-1"><a class="header-anchor" href="#_3-5-代码"><span>3.5 代码</span></a></h3><div class="language-python line-numbers-mode has-collapsed-lines collapsed" data-highlighter="shiki" data-ext="python" style="--vp-collapsed-lines:15;background-color:#272822;color:#F8F8F2;"><pre class="shiki monokai vp-code"><code><span class="line"><span style="color:#88846F;"># 定义一个Edge类来表示图中的边</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">class</span><span> </span><span style="color:#A6E22E;text-decoration:underline;">Edge</span><span style="color:#F8F8F2;">:</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">    def</span><span style="color:#66D9EF;"> __init__</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">self</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">u</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">v</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">weight</span><span style="color:#F8F8F2;">):</span></span>
<span class="line"><span style="color:#E6DB74;">        &quot;&quot;&quot;定义了一个边的数据结构,包含两个顶点和一个权重。&quot;&quot;&quot;</span></span>
<span class="line"><span style="color:#FD971F;">        self</span><span style="color:#F8F8F2;">.u </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> u              </span><span style="color:#88846F;"># 边的一个顶点 u / 边的起始顶点</span></span>
<span class="line"><span style="color:#FD971F;">        self</span><span style="color:#F8F8F2;">.v </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> v              </span><span style="color:#88846F;"># 边的另一个顶点v</span></span>
<span class="line"><span style="color:#FD971F;">        self</span><span style="color:#F8F8F2;">.weight </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> weight    </span><span style="color:#88846F;"># 边的权重weight</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;"># 定义并查集类（Union-Find）,用于检测环</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">class</span><span> </span><span style="color:#A6E22E;text-decoration:underline;">UnionFind</span><span style="color:#F8F8F2;">:</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">    def</span><span style="color:#66D9EF;"> __init__</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">self</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">vertices</span><span style="color:#F8F8F2;">):</span></span>
<span class="line"><span style="color:#88846F;">        # 初始化每个顶点的父节点为其自身,表示每个顶点都是一个独立的集合</span></span>
<span class="line"><span style="color:#FD971F;">        self</span><span style="color:#F8F8F2;">.parent </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> {vertex: vertex </span><span style="color:#F92672;">for</span><span style="color:#F8F8F2;"> vertex </span><span style="color:#F92672;">in</span><span style="color:#F8F8F2;"> vertices}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">    # 查找操作,找到顶点的根节点,并进行路径压缩</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">    def</span><span style="color:#A6E22E;"> find</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">self</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">vertex</span><span style="color:#F8F8F2;">):</span></span>
<span class="line"><span style="color:#88846F;">        # 如果当前顶点的父节点不是自己,递归寻找父节点,直到找到根节点</span></span>
<span class="line"><span style="color:#F92672;">        if</span><span style="color:#FD971F;"> self</span><span style="color:#F8F8F2;">.parent[vertex] </span><span style="color:#F92672;">!=</span><span style="color:#F8F8F2;"> vertex:</span></span>
<span class="line"><span style="color:#88846F;">            # 递归调用find,路径压缩,将当前节点直接连接到根节点</span></span>
<span class="line"><span style="color:#FD971F;">            self</span><span style="color:#F8F8F2;">.parent[vertex] </span><span style="color:#F92672;">=</span><span style="color:#FD971F;"> self</span><span style="color:#F8F8F2;">.find(</span><span style="color:#FD971F;">self</span><span style="color:#F8F8F2;">.parent[vertex])</span></span>
<span class="line"><span style="color:#88846F;">        # 返回根节点</span></span>
<span class="line"><span style="color:#F92672;">        return</span><span style="color:#FD971F;"> self</span><span style="color:#F8F8F2;">.parent[vertex]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">    # 合并操作,将两个顶点所在的集合合并为一个集合</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">    def</span><span style="color:#A6E22E;"> union</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">self</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">u</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">v</span><span style="color:#F8F8F2;">):</span></span>
<span class="line"><span style="color:#88846F;">        # 分别找到u和v的根节点</span></span>
<span class="line"><span style="color:#F8F8F2;">        root_u </span><span style="color:#F92672;">=</span><span style="color:#FD971F;"> self</span><span style="color:#F8F8F2;">.find(u)</span></span>
<span class="line"><span style="color:#F8F8F2;">        root_v </span><span style="color:#F92672;">=</span><span style="color:#FD971F;"> self</span><span style="color:#F8F8F2;">.find(v)</span></span>
<span class="line"><span style="color:#88846F;">        # 如果u和v的根节点相同,说明它们已经连通,合并会形成环,返回False</span></span>
<span class="line"><span style="color:#F92672;">        if</span><span style="color:#F8F8F2;"> root_u </span><span style="color:#F92672;">==</span><span style="color:#F8F8F2;"> root_v:</span></span>
<span class="line"><span style="color:#F92672;">            return</span><span style="color:#AE81FF;"> False</span></span>
<span class="line"><span style="color:#88846F;">        # 否则,将v的根节点的父节点指向u的根节点,合并两个集合</span></span>
<span class="line"><span style="color:#FD971F;">        self</span><span style="color:#F8F8F2;">.parent[root_v] </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> root_u</span></span>
<span class="line"><span style="color:#F92672;">        return</span><span style="color:#AE81FF;"> True</span><span style="color:#88846F;">  # 合并成功,返回True</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;"># Kruskal算法的主体函数</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">def</span><span style="color:#A6E22E;"> kruskal</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">vertices</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">edges</span><span style="color:#F8F8F2;">):</span></span>
<span class="line"><span style="color:#88846F;">    # 初始化并查集,传入所有顶点</span></span>
<span class="line"><span style="color:#F8F8F2;">    uf </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> UnionFind(vertices)</span></span>
<span class="line"><span style="color:#88846F;">    # 将所有边按照权重从小到大排序,使用lambda函数作为排序的键</span></span>
<span class="line"><span style="color:#F8F8F2;">    sorted_edges </span><span style="color:#F92672;">=</span><span style="color:#66D9EF;"> sorted</span><span style="color:#F8F8F2;">(edges, </span><span style="color:#FD971F;font-style:italic;">key</span><span style="color:#F92672;">=</span><span style="color:#66D9EF;font-style:italic;">lambda</span><span style="color:#FD971F;font-style:italic;"> edge</span><span style="color:#F8F8F2;">: edge.wight)</span></span>
<span class="line"><span style="color:#88846F;">    # 初始化最小生成树的边集合为空列表</span></span>
<span class="line"><span style="color:#F8F8F2;">    mst </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> []</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">    # 遍历排序后的边集合</span></span>
<span class="line"><span style="color:#F92672;">    for</span><span style="color:#F8F8F2;"> edge </span><span style="color:#F92672;">in</span><span style="color:#F8F8F2;"> sorted_edges:</span></span>
<span class="line"><span style="color:#88846F;">        # 尝试将当前边的两个顶点合并</span></span>
<span class="line"><span style="color:#F92672;">        if</span><span style="color:#F8F8F2;"> uf.union(edge.u, edge.v):</span></span>
<span class="line"><span style="color:#88846F;">            # 如果合并成功,说明没有形成环,将该边加入最小生成树</span></span>
<span class="line"><span style="color:#F8F8F2;">            mst.append(edge)</span></span>
<span class="line"><span style="color:#88846F;">            # 如果最小生成树的边数等于顶点数减一,生成树构建完成,退出循环</span></span>
<span class="line"><span style="color:#F92672;">            if</span><span style="color:#66D9EF;"> len</span><span style="color:#F8F8F2;">(mst) </span><span style="color:#F92672;">==</span><span style="color:#66D9EF;"> len</span><span style="color:#F8F8F2;">(vertices) </span><span style="color:#F92672;">-</span><span style="color:#AE81FF;"> 1</span><span style="color:#F8F8F2;">:</span></span>
<span class="line"><span style="color:#F92672;">                break</span></span>
<span class="line"><span style="color:#F92672;">        else</span><span style="color:#F8F8F2;">:</span></span>
<span class="line"><span style="color:#88846F;">            # 合并失败,说明加入该边会形成环,跳过该边</span></span>
<span class="line"><span style="color:#F92672;">            continue</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">    # 返回构建好的最小生成树的边集合</span></span>
<span class="line"><span style="color:#F92672;">    return</span><span style="color:#F8F8F2;"> mst</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;"># 主程序入口,测试代码</span></span>
<span class="line"><span style="color:#F92672;">if</span><span style="color:#F8F8F2;"> __name__ </span><span style="color:#F92672;">==</span><span style="color:#E6DB74;"> &quot;__main__&quot;</span><span style="color:#F8F8F2;">:</span></span>
<span class="line"><span style="color:#88846F;">    # 定义图的顶点集合</span></span>
<span class="line"><span style="color:#F8F8F2;">    vertices </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> [</span><span style="color:#E6DB74;">&#39;A&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&#39;B&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&#39;C&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&#39;D&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&#39;E&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&#39;F&#39;</span><span style="color:#F8F8F2;">]</span></span>
<span class="line"><span style="color:#88846F;">    # 定义图的边集合,创建Edge实例,传入两个顶点和边的权重</span></span>
<span class="line"><span style="color:#F8F8F2;">    edges </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> [</span></span>
<span class="line"><span style="color:#F8F8F2;">        Edge(</span><span style="color:#E6DB74;">&#39;A&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&#39;B&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">4</span><span style="color:#F8F8F2;">),</span></span>
<span class="line"><span style="color:#F8F8F2;">        Edge(</span><span style="color:#E6DB74;">&#39;A&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&#39;F&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">2</span><span style="color:#F8F8F2;">),</span></span>
<span class="line"><span style="color:#F8F8F2;">        Edge(</span><span style="color:#E6DB74;">&#39;B&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&#39;C&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">6</span><span style="color:#F8F8F2;">),</span></span>
<span class="line"><span style="color:#F8F8F2;">        Edge(</span><span style="color:#E6DB74;">&#39;B&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&#39;F&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">5</span><span style="color:#F8F8F2;">),</span></span>
<span class="line"><span style="color:#F8F8F2;">        Edge(</span><span style="color:#E6DB74;">&#39;C&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&#39;D&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">3</span><span style="color:#F8F8F2;">),</span></span>
<span class="line"><span style="color:#F8F8F2;">        Edge(</span><span style="color:#E6DB74;">&#39;C&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&#39;E&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">7</span><span style="color:#F8F8F2;">),</span></span>
<span class="line"><span style="color:#F8F8F2;">        Edge(</span><span style="color:#E6DB74;">&#39;D&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&#39;E&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">8</span><span style="color:#F8F8F2;">),</span></span>
<span class="line"><span style="color:#F8F8F2;">        Edge(</span><span style="color:#E6DB74;">&#39;D&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&#39;F&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">4</span><span style="color:#F8F8F2;">),</span></span>
<span class="line"><span style="color:#F8F8F2;">        Edge(</span><span style="color:#E6DB74;">&#39;E&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#E6DB74;">&#39;F&#39;</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">1</span><span style="color:#F8F8F2;">)</span></span>
<span class="line"><span style="color:#F8F8F2;">    ]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">    # 调用kruskal函数,传入顶点和边集合,获取最小生成树的边集合</span></span>
<span class="line"><span style="color:#F8F8F2;">    mst </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> kruskal(vertices, edges)</span></span>
<span class="line"><span style="color:#88846F;">    # 输出最小生成树的边和总权重</span></span>
<span class="line"><span style="color:#66D9EF;">    print</span><span style="color:#F8F8F2;">(</span><span style="color:#E6DB74;">&quot;最小生成树的边为：&quot;</span><span style="color:#F8F8F2;">)</span></span>
<span class="line"><span style="color:#F8F8F2;">    total_weight </span><span style="color:#F92672;">=</span><span style="color:#AE81FF;"> 0</span><span style="color:#88846F;">  # 初始化总权重</span></span>
<span class="line"><span style="color:#88846F;">    # 遍历最小生成树的边集合</span></span>
<span class="line"><span style="color:#F92672;">    for</span><span style="color:#F8F8F2;"> edge </span><span style="color:#F92672;">in</span><span style="color:#F8F8F2;"> mst:</span></span>
<span class="line"><span style="color:#88846F;">        # 输出每条边的两个顶点和权重</span></span>
<span class="line"><span style="color:#66D9EF;">        print</span><span style="color:#F8F8F2;">(</span><span style="color:#66D9EF;font-style:italic;">f</span><span style="color:#E6DB74;">&quot;</span><span style="color:#AE81FF;">{</span><span style="color:#F8F8F2;">edge.u</span><span style="color:#AE81FF;">}</span><span style="color:#E6DB74;"> - </span><span style="color:#AE81FF;">{</span><span style="color:#F8F8F2;">edge.v</span><span style="color:#AE81FF;">}</span><span style="color:#E6DB74;">, 权重: </span><span style="color:#AE81FF;">{</span><span style="color:#F8F8F2;">edge.weight</span><span style="color:#AE81FF;">}</span><span style="color:#E6DB74;">&quot;</span><span style="color:#F8F8F2;">)</span></span>
<span class="line"><span style="color:#88846F;">        # 累加总权重</span></span>
<span class="line"><span style="color:#F8F8F2;">        total_weight </span><span style="color:#F92672;">+=</span><span style="color:#F8F8F2;"> edge.weight</span></span>
<span class="line"><span style="color:#88846F;">    # 输出最小生成树的总权重</span></span>
<span class="line"><span style="color:#66D9EF;">    print</span><span style="color:#F8F8F2;">(</span><span style="color:#66D9EF;font-style:italic;">f</span><span style="color:#E6DB74;">&quot;最小生成树的总权重为：</span><span style="color:#AE81FF;">{</span><span style="color:#F8F8F2;">total_weight</span><span style="color:#AE81FF;">}</span><span style="color:#E6DB74;">&quot;</span><span style="color:#F8F8F2;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="collapsed-lines"></div></div><h2 id="_4-kruskal-和-prim-区别" tabindex="-1"><a class="header-anchor" href="#_4-kruskal-和-prim-区别"><span>4. Kruskal 和 Prim 区别</span></a></h2><p>Kruskal 算法和 Prim 算法都是解决最小生成树（MST）问题的贪心算法,但它们在实现上有一些关键的区别。这些区别主要体现在选择边的方式、适用的图类型以及底层的数据结构上。</p><h3 id="_1-主要区别" tabindex="-1"><a class="header-anchor" href="#_1-主要区别"><span>1. 主要区别</span></a></h3><table><thead><tr><th>区别</th><th>Kruskal算法</th><th>Prim算法</th></tr></thead><tbody><tr><td><strong>算法类型</strong></td><td>基于边的选择</td><td>基于顶点的扩展</td></tr><tr><td><strong>执行方式</strong></td><td>按权重对所有边排序,然后依次选取边来构建MST</td><td>从一个起点开始,逐步扩展MST</td></tr><tr><td><strong>适用图类型</strong></td><td>更适合<strong>稀疏图</strong>（边较少的图）</td><td>更适合<strong>稠密图</strong>（边较多的图）</td></tr><tr><td><strong>数据结构</strong></td><td>并查集（Union-Find）</td><td>最小堆（优先队列）</td></tr></tbody></table><h3 id="_2-详细解释" tabindex="-1"><a class="header-anchor" href="#_2-详细解释"><span>2. 详细解释</span></a></h3><h4 id="选择边的方式" tabindex="-1"><a class="header-anchor" href="#选择边的方式"><span>选择边的方式</span></a></h4><ul><li><p><strong>Kruskal算法</strong>：选择<strong>权重最小</strong>的边,逐步将这些边添加到最小生成树中,前提是不形成环。Kruskal是<strong>基于边的选择</strong>,所以它从全局的角度出发,先对所有边排序,再从权重最小的边开始。</p></li><li><p><strong>Prim算法</strong>：从一个<strong>起始顶点</strong>出发,不断选择与已选顶点连接的<strong>权重最小的边</strong>扩展MST。因此,Prim是<strong>基于顶点的扩展</strong>,每次只考虑与当前生成树连接的边。它逐步扩展MST,直到所有顶点都被包括。</p></li></ul><h4 id="执行方式" tabindex="-1"><a class="header-anchor" href="#执行方式"><span>执行方式</span></a></h4><ul><li><p><strong>Kruskal算法</strong>：算法先对边按权重排序,然后从权重最小的边开始,逐条检查并加入MST,直到所有顶点连接在一起。对于每条边,都用并查集检查是否会形成环。</p></li><li><p><strong>Prim算法</strong>：Prim算法从一个顶点开始,将与当前生成树相连的最小权重边加入生成树。通过最小堆存储边的权重并逐步扩展,直到生成树覆盖所有顶点。</p></li></ul><h4 id="适用图类型" tabindex="-1"><a class="header-anchor" href="#适用图类型"><span>适用图类型</span></a></h4><ul><li><p><strong>Kruskal算法</strong>：因为Kruskal算法是基于边的选择和排序,对边较少的<strong>稀疏图</strong>效率更高。边的数量较少,排序和边选择过程会更快。</p></li><li><p><strong>Prim算法</strong>：Prim算法适合边较多的<strong>稠密图</strong>,因为它从一个顶点逐步扩展,只需要维护与当前生成树相连的边集合。特别是用邻接矩阵或优先队列实现时,效率较高。</p></li></ul><h4 id="数据结构" tabindex="-1"><a class="header-anchor" href="#数据结构"><span>数据结构</span></a></h4><ul><li><p><strong>Kruskal算法</strong>：通常使用并查集来管理生成树的连接状态,以便快速合并集合和检测环。</p></li><li><p><strong>Prim算法</strong>：用最小堆或优先队列来维护与当前生成树相连的边,以便快速找到权重最小的边进行扩展。</p></li></ul><h3 id="_3-适用场景举例" tabindex="-1"><a class="header-anchor" href="#_3-适用场景举例"><span>3. 适用场景举例</span></a></h3><ul><li><p><strong>Kruskal算法适合场景</strong>：适合边较少、图不连通的情况。例如,将一些点连接成网络,而这些点可能分布在较大的区域且连接稀疏。</p></li><li><p><strong>Prim算法适合场景</strong>：适合边较多的连通图。例如,电网、城市道路等密集连接的网络。</p></li></ul><h3 id="_4-总结" tabindex="-1"><a class="header-anchor" href="#_4-总结"><span>4. 总结</span></a></h3><ul><li><strong>Kruskal</strong> 是通过从所有边中选择权重最小的边来逐步构建MST,适合稀疏图。</li><li><strong>Prim</strong> 是通过从起始顶点逐步扩展最小生成树,适合稠密图。</li></ul>`,25))])}const k=o(t,[["render",A]]),_=JSON.parse('{"path":"/zh/Advanced_Algorithms/Week06.html","title":"高级算法——第6周ppt总结","lang":"zh-CN","frontmatter":{"title":"高级算法——第6周ppt总结","icon":"python","date":"2024-10-30T11:28:41.000Z","author":"XiaoXianYue","isOriginal":true,"category":["大三上","高级算法课件"],"tag":["大三上","高级算法课件"],"sticky":false,"star":false,"article":true,"timeline":true,"image":false,"navbar":true,"sidebarIcon":true,"headerDepth":5,"lastUpdated":true,"editLink":false,"backToTop":true,"toc":true,"description":"1. Dijkstra’s algorithm 算法目标和使用场景 使用 Dijkstra 算法,可以寻找图中节点之间的最短路径。特别是,可以在图中寻找一个节点（称为“源节点”）到所有其它节点的最短路径,生成一个最短路径树。 GPS 设备使用这个算法来寻找当前位置到目标位置的最短路径。Dijkstra 算法被广泛应用在工业上,尤其是需要建模网络的领域。...","head":[["meta",{"property":"og:url","content":"https://bougiemoonintaurus/zh/Advanced_Algorithms/Week06.html"}],["meta",{"property":"og:site_name","content":"奶酪奶酪"}],["meta",{"property":"og:title","content":"高级算法——第6周ppt总结"}],["meta",{"property":"og:description","content":"1. Dijkstra’s algorithm 算法目标和使用场景 使用 Dijkstra 算法,可以寻找图中节点之间的最短路径。特别是,可以在图中寻找一个节点（称为“源节点”）到所有其它节点的最短路径,生成一个最短路径树。 GPS 设备使用这个算法来寻找当前位置到目标位置的最短路径。Dijkstra 算法被广泛应用在工业上,尤其是需要建模网络的领域。..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-05T09:12:10.000Z"}],["meta",{"property":"article:author","content":"XiaoXianYue"}],["meta",{"property":"article:tag","content":"大三上"}],["meta",{"property":"article:tag","content":"高级算法课件"}],["meta",{"property":"article:published_time","content":"2024-10-30T11:28:41.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-05T09:12:10.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"高级算法——第6周ppt总结\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-10-30T11:28:41.000Z\\",\\"dateModified\\":\\"2024-12-05T09:12:10.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"XiaoXianYue\\"}]}"]]},"git":{"createdTime":1729850625000,"updatedTime":1733389930000,"contributors":[{"name":"Xiaoxianyue","username":"Xiaoxianyue","email":"2310219843@qq.com","commits":13,"url":"https://github.com/Xiaoxianyue"}]},"readingTime":{"minutes":16.13,"words":4839},"filePathRelative":"zh/Advanced_Algorithms/Week06.md","localizedDate":"2024年10月30日","excerpt":"<h2>1. Dijkstra’s algorithm</h2>\\n<p>算法目标和使用场景<br>\\n使用 Dijkstra 算法,可以寻找图中节点之间的最短路径。特别是,可以在图中寻找一个节点（称为“源节点”）到所有其它节点的最短路径,生成一个最短路径树。</p>\\n<p>GPS 设备使用这个算法来寻找当前位置到目标位置的最短路径。Dijkstra 算法被广泛应用在工业上,尤其是需要建模网络的领域。</p>\\n<h3>1.1 基础知识</h3>\\n<ol>\\n<li>Dijkstra‘s 算法从指定的节点（源节点）出发,寻找它与图中所有其他节点之间的最短路径。</li>\\n<li>Dijkstra’s 算法会记录当前已知最短路径,并在寻找更短的路径时更新。</li>\\n<li>一旦找到源节点与其他节点之间的最短路径,那个节点会被标记为“已访问”并添加到路径中。</li>\\n<li>重复寻找过程,直到图中所有节点都已经添加到路径中,这样就可以得到从源节点出发访问所有其他节点的最短路径方案。</li>\\n</ol>","autoDesc":true}');export{k as comp,_ as data};
