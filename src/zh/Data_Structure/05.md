---
title: 图
icon: c
date: 2024-5-22 13:51:05
author: XiaoXianYue
isOriginal: true
category: 
    - 数据结构
    - 大二下
tag:
    - 数据结构
    - 大二下
sticky: false
star: false
article: true
timeline: true
image: false
navbar: true
sidebarIcon: true
headerDepth: 5
lastUpdated: true
editLink: false
backToTop: true
toc: true
---

 ## 1. 图的基本概念

### 1.1 图的定义

`G=(V,E)`

V：顶点（数据元素）的有穷非空集合

E：边的有穷集合 

![image-20240522135708580](./05.assets/image-20240522135708580.png)

 

### 1.2 图的基本术语

1. 无向图中：端点和邻接点

​        有向图中：起始端点和终止端点；出边邻接点和入边邻接点

2. 顶点的度，出度和入度

​       一个顶点所关联的边的数目称为顶点的度。有向图里分出度和入度。

> 如果一个图中有n个顶点和e条边,每个顶点的度为di(0<=i<=n-1),则有:

![image-20240522141335248](./05.assets/image-20240522141335248.png)

> 也就是说一个图中所有顶点的度之和等于边数的两倍.

3. 完全图

无向图每个顶点之间都存在这一条边;有向图每个顶点之间都存在着双向边.

<img src="./05.assets/image-20240522141628815.png" alt="image-20240522141628815" style="zoom:50%;" />

4. 稠密图和稀疏图

字面意思

5. 子图

![image-20240522141740079](./05.assets/image-20240522141740079.png)

6. 路径和路径长度,简单路径
7. 回路和环

开始点和结束点是同一个顶点

8. 连通,连通图和连通分量

<img src="./05.assets/image-20240522143249513.png" alt="image-20240522143249513" style="zoom:67%;" />

9. 强连通图和强连通分量

<img src="./05.assets/image-20240522143447209.png" alt="image-20240522143447209" style="zoom: 67%;" />

> 怎么把非强连通图的强连通分量找出来?

<img src="./05.assets/image-20240522144125827.png" alt="image-20240522144125827" style="zoom: 50%;" />

10. 权和网

![image-20240522144451563](./05.assets/image-20240522144451563.png)

![image-20240522144647883](./05.assets/image-20240522144647883.png)

## 2. 图的存储结构和基本运算算法

### 2.1 邻接矩阵存储方法

 ![image-20240522164932916](./05.assets/image-20240522164932916.png)

#### 2.1.1 无向图的邻接矩阵:

![image-20240522165712211](./05.assets/image-20240522165712211.png)

> **在完全无向图的邻接矩阵中,除了对角线上的元素都是0,其他都是1**

#### 2.1.2 有向图的邻接矩阵：

![image-20240522170731600](./05.assets/image-20240522170731600.png)

在行处有1的就是该结点发出的箭头（出度边）；在列处有1就是该结点收到的箭头（入度边）。

<img src="./05.assets/image-20240522171420514.png" alt="image-20240522171420514" style="zoom:67%;" />



#### 2.1.3 网的邻接矩阵

![image-20240522171853628](./05.assets/image-20240522171853628.png)



#### 2.1.4 邻接矩阵的建立

<img src="./05.assets/image-20240522173351774.png" alt="image-20240522173351774" style="zoom:67%;" />



邻接矩阵适合存放稠密图。

图的邻接矩阵是唯一的。

邻接矩阵的空间复杂度是O(n^2)

### 2.2 邻接表

#### 2.2.1 无向图的邻接表

<img src="./05.assets/image-20240522175007111.png" alt="image-20240522175007111" style="zoom:67%;" />

#### 2.2.2 有向图

<img src="./05.assets/image-20240522175509626.png" alt="image-20240522175509626" style="zoom:80%;" />

也有逆邻接表

<img src="./05.assets/image-20240522175558636.png" alt="image-20240522175558636" style="zoom:67%;" />

<img src="./05.assets/image-20240522175606176.png" alt="image-20240522175606176" style="zoom:67%;" />



练习：

![image-20240522180023266](./05.assets/image-20240522180023266.png)

#### 2.2.3 特点

![image-20240522181215976](./05.assets/image-20240522181215976.png)

邻接表适合于稀疏图。

邻接表不唯一

邻接表·的空间复杂度O(n+e)







## 3.图的遍历

设置辅助数组：

![image-20240522205558980](./05.assets/image-20240522205558980.png)



### 3.1 深度优先搜索(DFS)

#### 3.1.1 连通图

“一条路走到黑”：

<img src="./05.assets/image-20240522205907030.png" alt="image-20240522205907030" style="zoom:50%;" />

下面例题，自己再做一遍：

![image-20240522212445598](./05.assets/image-20240522212445598.png)

遍历图中每一个顶点都要从头扫描该顶点所在行，时间复杂度为O(n^2)。

但是在邻接表中，时间复杂度为O(n+e)，n是头节点数目，e是图中边数。



#### 3.1.2 非连通图

是一样的

遍历完一个连通分量就遍历另一个。

<img src="./05.assets/image-20240522221229805.png" alt="image-20240522221229805" style="zoom:50%;" />



### 3.2 广度优先搜索（BFS）

1. 连通图

![image-20240522221710764](./05.assets/image-20240522221710764.png)

2. 非连通图

是一样的 分别访问连通分量。

#### 3.2.1 算法实现

![image-20240522222350421](./05.assets/image-20240522222350421.png)

#### 3.2.2 效率分析

使用邻接矩阵，O(n^2)

使用邻接表，O(n+e）

 ##### 3.2.2.1 DFS和BFS的算法效率比较

空间复杂度相同，都是O(n)（借用了堆栈或者队列）

时间效率见上文。都是一样。

  

 

## 4. 图的应用

### 4.1 最小生成树

#### 4.1.1 生成树

<img src="./05.assets/image-20240522223852829.png" alt="image-20240522223852829" style="zoom:67%;" /> 

特点

- 生成树的顶点个数与图的顶点个数相同
- 生成树是图的极小连通子图，去掉一条边则非连通。

- n个顶点的生成树有n-1条边
- 在生成树中再加一条边必然形成回路。（生成树不能有回路）
- 任意两个顶点之间的路径是唯一的

#### 4.1.2 最小生成树（MST）

<img src="./05.assets/image-20240522224712119.png" alt="image-20240522224712119" style="zoom:80%;" />

#### 4.1.3 如何构造最小生成树

MST性质解释：

![image-20240522230552480](./05.assets/image-20240522230552480.png)

1. 普里姆算法

2. 克鲁斯卡尔算法（出来的生成树有可能不唯一）

![image-20240522231750187](./05.assets/image-20240522231750187.png)

对比：![image-20240522231903750](./05.assets/image-20240522231903750.png)



### 4.2 最短路径问题

在有向网中A点（源点）到达B点（终点）的多条路径中，寻找一条各边权值之和最小的路径，即最短路径。与最小生成树不同，路径上不一定包含n个顶点，也不一定包含n-1条边。

<img src="./05.assets/image-20240522232650336.png" alt="image-20240522232650336" style="zoom: 67%;" />

![image-20240522232800523](./05.assets/image-20240522232800523.png)

#### 4.2.1 Dijkstra算法（求解单源最短路径）

 ![image-20240523004757810](./05.assets/image-20240523004757810.png)



#### 4.2.2 Floyd（弗洛伊德）算法（所有顶点间得最短路径）

![image-20240523012855303](./05.assets/image-20240523012855303.png)





 







