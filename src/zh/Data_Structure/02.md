---
title: 线性表
icon: c
date: 2024-5-17 20:09:44
author: XiaoXianYue
isOriginal: true
category: 
    - 数据结构
    - 大二下
tag:
    - 数据结构
    - 大二下
sticky: false
star: false
article: true
timeline: true
image: false
navbar: true
sidebarIcon: true
headerDepth: 5
lastUpdated: true
editLink: false
backToTop: true
toc: true
---

## 1. 线性表及其逻辑结构

### 1.1 线性表的定义

#### 1.1.1 基本定义

线性表是一个具有相同特性的数据元素的有限序列。该序列中所含元素的个数叫做线性表的长度，用n表示，n>=0。

线性表的一般表示为：

​               ![image-20240517202317251](./02.assets/image-20240517202317251.png)

一些关于线性表的定义：

<img src="./02.assets/image-20240517202435433.png" alt="image-20240517202435433" style="zoom:67%;" />

线性表用二元组来表示：L = （D ，R），其中：

![image-20240517202733327](./02.assets/image-20240517202733327.png)

逻辑结构的示意图是：

<img src="./02.assets/image-20240517202804240.png" alt="image-20240517202804240" style="zoom:67%;" />





#### 1.1.2 特点

有穷性：元素个数有限

一致性：元素性质相同

序列性：元素之间相对位置是线性的



#### 1.1.3 线性表的例子

<img src="./02.assets/image-20240517203225313.png" alt="image-20240517203225313" style="zoom:50%;" />

> 图片截自bilibili–青岛大学 王卓



### 1.2 线性表的抽象数据类型表述

![image-20240517203710552](./02.assets/image-20240517203710552.png)

![image-20240517203721489](./02.assets/image-20240517203721489.png)







## 2. 线性表的顺序存储结构



### 2.1 线性表的顺序存储结构——顺序表

#### 2.1.1 定义（线性表长什么样子）

顺序存储定义:把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构. 比如线性表.

![image-20240517211219659](./02.assets/image-20240517211219659.png)

书上说明图也可以看出来,这掉落某个元素的存储位置就可以计算其他元素位置.

<img src="./02.assets/image-20240517211139860.png" alt="image-20240517211139860" style="zoom:67%;" />

#### 2.1.2 例题

![image-20240517211622722](./02.assets/image-20240517211622722.png)



### 2.2 顺序表基本运算实现

#### 2.2.1 建立顺序表

![image-20240517211853521](./02.assets/image-20240517211853521.png)

> 在这里L是输出型参数，简称形参；

或者这样更加清楚直观：

<img src="./02.assets/image-20240517212024638.png" alt="image-20240517212024638" style="zoom: 67%;" />

#### 2.2.2 顺序表的基本运算方法

1. 初始化线性表：InitList（&L）——构造一个空的线性表L

![image-20240517214013182](./02.assets/image-20240517214013182.png)

![image-20240517214213550](./02.assets/image-20240517214213550.png)

2. 销毁线性表：DestroyList（&L）——释放线性表占用的空间。

<img src="./02.assets/image-20240517214141624.png" alt="image-20240517214141624" style="zoom: 80%;" />

3. 判断线性表是否为空表: ListEmpty(L) ——返回一个布尔值

![image-20240517214342187](./02.assets/image-20240517214342187.png)

4. 求线性表长度：ListLength(L)——

![image-20240517214615303](./02.assets/image-20240517214615303.png)

5. 输出线性表：DispList(L)——依次输出L中各元素的值

![image-20240517220034089](./02.assets/image-20240517220034089.png)

6. 按序号求线性表中的元素：GetElem(L)

    ![image-20240517220334096](./02.assets/image-20240517220334096.png)

7. 按元素值查找：

    ![image-20240517220544004](./02.assets/image-20240517220544004.png)

    > 基本操作：L.elem[i] == e；

    > 存储序号为i，返回逻辑序号，是i+1。

8. 插入数据元素：![image-20240517220704496](./02.assets/image-20240517220704496.png)

<img src="./02.assets/image-20240517221014085.png" alt="image-20240517221014085" style="zoom:67%;" />

各种位置添加元素的平均移动次数：n/2

时间复杂度：O(n)

9. 删除数据元素

<img src="./02.assets/image-20240517221049594.png" alt="image-20240517221049594" style="zoom:80%;" />

<img src="./02.assets/image-20240517221829278.png" alt="image-20240517221829278" style="zoom:67%;" />



各种位置删除元素的平均移动次数：(n-1)/2

时间复杂度：O(n)



### 2.3 顺序表小结

优点与缺点：

- **存储方式**：线性表的顺序存储结构是将元素顺序地存储在一块连续的存储区域内，每个元素占据一个存储位置。

**特点**：

- **随机访问**：通过基址和索引直接计算出元素的存储位置，支持高效的随机访问。
- **存储密度高**：不需要额外空间存储元素之间的逻辑关系，存储利用率高。
- **扩展困难**：当存储空间不足时，需要进行扩展，可能会涉及到数据的整体移动，效率较低。
- **插入和删除操作**：需要移动大量元素，操作效率相对较低。





## 3. 链表

### 3.1 链表是什么

**指针域和数字域：**

  线性表的每个元素用一个内存节点存储，每个内存节点不仅包含元素本身的信息（数字域），而且包含表示元素之间逻辑关系的信息。在C/C++中采用指针来实现，这称为指针域。

**单链表：**

  由于线性表中元素最多有一个前驱元素，一个后继元素，所以当采用链表存储时，我们只设置一个指针域用于指向后继结点。这样构成的链表称为线性单向链接表，简称单链表。

**双链表：**

  另一种方法是设置两个指针域，分别用于指向其前驱结点和后继结点，这样构成的链表称为线性双向链接表，简称双链表。

**首尾指针：**

通常每个链表有一个头结点，并通过头结点的指针唯一标识该链表，称之为头指针（head pointer），相应的指向首节点或者开始结点的指针成为首指针，指向尾节点的指针称为尾指针。



### 3.2 单链表

![image-20240518164930514](./02.assets/image-20240518164930514.png)

#### 3.2.1 插入和删除结点操作

1. 插入节点的操作

![image-20240518165458228](./02.assets/image-20240518165458228.png)

如下修改（C/C++）：

```c
s ->next = p ->next;
p ->next = s;
```



2. 删除节点的操作

![image-20240518165750766](./02.assets/image-20240518165750766.png)

```c
q = p ->next; //q临时保存被删结点
p ->next = q ->next; //从链表中删掉结点q
free(q);  //释放结点q的空间
```



#### 3.2.2 建立单链表

1. 头插法

    ![image-20240518171451966](./02.assets/image-20240518171451966.png)

该方法从一个空表开始依次读取数组a中的元素，生成一个新节点（由s指向它），将读取的数组元素存放到该结点的数据域中，然后将其插到当前链表的表头（即头结点之后）。

![image-20240518170737382](./02.assets/image-20240518170737382.png)

![image-20240518170749322](./02.assets/image-20240518170749322.png)

头插法分两步：一个是把头结点(L)后面的东西都放到新结点后面去，再把头结点后面接上新结点的指针。

时间复杂度O(n)

2. 尾插法

![image-20240518170851070](./02.assets/image-20240518170851070.png)

重点是：r必须一直是尾指针。



### 3.3 双链表