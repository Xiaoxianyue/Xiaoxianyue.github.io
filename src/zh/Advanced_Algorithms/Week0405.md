---
title: 高级算法——第4,5周查漏补缺
icon: python
date: 2024-11-06 16:04:18
author: XiaoXianYue
isOriginal: true
category: 
    - 大三上
    - 高级算法课件
tag:
    - 大三上
    - 高级算法课件
sticky: false
star: false
article: true
timeline: true
image: false
navbar: true
sidebarIcon: true
headerDepth: 5
lastUpdated: true
editLink: false
backToTop: true
toc: true
---

## week 04

### 1. BST 的查找，插入与删除

#### 循环的——查找插入删除

```python
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None


class BST:
    def __init__(self):
        self.root = None

    def find(self, key):
        cur = self.root
        while cur != None:
            if cur.val == key:
                return cur
            elif cur.val > key:
                cur = cur.left
            else:
                cur = cur.right
        return False

    def insert(self, key):
        cur, pre = self.root, None
        while cur != None:
            if cur.val == key:
                return
            pre = cur
            if cur.val > key:
                cur = cur.left
            elif cur.val < key:
                cur = cur.right
        node = TreeNode(key)
        if pre.val > key:
            pre.left = node
        else:
            pre.right = node

    def delete(self, key):
        cur, pre = self.root, None
        while cur.val != key:
            if cur is None:
                return False
            pre = cur
            if cur.val > key:
                cur = cur.left
            else:
                cur = cur.right
        if cur.left is None or cur.right is None:
            child = cur.right or cur.left
            if pre.left == cur:
                pre.left = child
            else:
                pre.right = child
        else:
            replace_cur = self.find_min(cur)
            cur.val = replace_cur.val

    def find_min(self, node):
        if node is None:
            return None
        node = node.right
        while node.left is not None:
            node = node.left
        return node



if __name__ == '__main__':
    # 手动创建二叉搜索树
    bst = BST()
    bst.root = TreeNode(4)
    bst.root.left = TreeNode(2)
    bst.root.right = TreeNode(6)

    bst.root.left.left = TreeNode(1)
    bst.root.left.right = TreeNode(3)

    bst.root.right.left = TreeNode(5)
    bst.root.right.right = TreeNode(7)

    bst.insert(8)
    bst.delete(8)

    # 测试查找节点
    node = bst.find(8)
    if node:
        print(f"找到了节点，值为: {node.val}")  # 打印该节点的值
    else:
        print("未找到节点")
```



#### 递归的——查找插入删除

```python
class TreeNode:
    """二叉树节点类"""

    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None




class BST:
    def __init__(self):
        self.root = None


    def search(self, root, val):
        if root is None:
            return None
        if val < root.val:
            return self.search(root.left, val)
        elif val > root.val:
            return self.search(root.right, val)
        else:
            return root  # 这里是返回了该节点的地址，而不是值


    def insert(self, root, num):
        if root is None:
            return TreeNode(num)
        if num < root.val:
            root.left = self.insert(root.left, num)
        elif num > root.val:
            root.right = self.insert(root.right, num)
        return root

    def delete(self, root, key):
        if root is None:
            return root
        if key < root.val:
            root.left = self.delete(root.left, key)
        elif key > root.val:
            root.right = self.delete(root.right, key)
        else:
            if root.left is None and root.right is None:
                return None
            elif root.left:
                return root.left
            elif root.right:
                return root.right
            else:
                min_find_num = self.find_min(root.right)
                min_find_num.val = root.val
                root.right = self.delete(root.right, min_find_num)
                return root
    def find_min(self,root):
        current = root
        while current.left is not None:
            current = current.left
        return current



if __name__ == '__main__':
    bst = BST()
    bst.root = bst.insert(bst.root,6)
    bst.insert(bst.root, 3)
    bst.insert(bst.root, 9)
    bst.insert(bst.root, 1)
    bst.insert(bst.root, 2)
    bst.insert(bst.root, 7)

    bst.insert(bst.root, 10)
    bst.delete(bst.root, 5)

    # 测试查找节点
    node = bst.search(bst.root, 10)
    if node:
        print(f"找到了节点，值为: {node.val}") # 打印该节点的值
    else:
        print("未找到节点")
```













### 2. BST 的遍历

#### 2.1 Pre Order

```python
res = []
def preorder(root: TreeNode):
    if root is None:
        return
    res.append(root.val)
    if root.left is not None:
        inorder(root.left)
    if root.right:
        inorder(root.right)

preorder(n1)
print(res)
```

#### 2.2 In Order

```python
res = []
def inorder(root: TreeNode):
    if root is None:
        return
    if root.left is not None:
        inorder(root.left)
        res.append(root.val)
    if root.right:
        inorder(root.right)


inorder(n1)
print(res)
```



#### 2.3 Post Order

```python
res = []
def postorder(root: TreeNode):
    if root is None:
        return
    if root.left is not None:
        inorder(root.left)
    if root.right:
        inorder(root.right)
    res.append(root.val)


postorder(n1)
print(res)
```



### 3. 广度遍历和深度遍历

#### 3.1 广度遍历（BFS）



```python
class TreeNode:
    def __init__(self, val: int):
        self.val = val
        self.left = None
        self.right = None
n1 = TreeNode(val=1)
n2 = TreeNode(val=2)
n3 = TreeNode(val=3)
n4 = TreeNode(val=4)
n5 = TreeNode(val=5)
n6 = TreeNode(val=6)
n7 = TreeNode(val=7)
n1.left = n2
n1.right = n3
n2.left = n4
n2.right = n5
n3.left = n6
n3.right = n7

def level_order(root):
    queue = []
    if root is not None:
        queue.append(root)
    res = []

    while queue:
        node = queue.pop(0)
        res.append(node.val)
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    return res

print(level_order(n1))
```

```python
class TreeNode:
    """二叉树节点类"""

    def __init__(self, val: int):
        self.val: int = val  # 节点值
        self.left: 'TreeNode' | None = None  # 左子节点引用
        self.right: 'TreeNode' | None = None  # 右子节点引用


n1 = TreeNode(val=1)
n2 = TreeNode(val=2)
n3 = TreeNode(val=3)
n4 = TreeNode(val=4)
n5 = TreeNode(val=5)
n6 = TreeNode(val=6)
n7 = TreeNode(val=7)
n1.left = n2
n1.right = n3
n2.left = n4
n2.right = n5
n3.left = n6
n3.right = n7



def level_order_recursive(root):
    res = []
    if root:
        level_helper([root], res)
    return res


def level_helper(queue, res):
    if not queue:
        return
    node = queue.pop(0)
    res.append(node.val)
    if node.left:
        queue.append(node.left)
    if node.right:
        queue.append(node.right)

    level_helper(queue, res)


print(level_order_recursive(n1))
```



#### 3.2 深度遍历（就是先中后序遍历）





### 5. Balanced and Unbalanced Trees 查找。无意义



### 6. AVL Trees

```python
class TreeNode:
    def __init__(self, val):
        self.height = 0
        self.val = val
        self.left = None
        self.right = None

    def get_height(self, node):
        if node is not None:
            return node.height
        return -1

    def update_height(self, node):
        return max([self.get_height(node.left), self.get_height(node.right)]) + 1

    def balance_factor(self, node):
        if node is None:
            return 0
        return self.get_height(node.left) - self.get_height(node.right)

    def right_rotation(self, node):
        child = node.left
        grand_child = child.right

        child.right = node
        node.left = grand_child
        self.update_height(child)
        self.update_height(node)
        return child
    def left_rotation(self, node):
        child =node.right
        grand_child = child.left

        child.left = node
        node.right = grand_child
        self.update_height(child)
        self.update_height(node)
        return child

    def roration(self, node):
        balance_factor = self.balance_factor(node)
        if balance_factor > 1:
            if self.balance_factor(node.left) >= 0:
                self.right_rotation(node)
            else:
                self.left_rotation(node.left)
                self.left_rotation(node)
        elif balance_factor < -1:
            if self.balance_factor(node.right) >= 0:
                self.left_rotation(node)
            else:
                self.right_rotation(node.left)
                self.left_rotation(node)
        return node

    def insert(self, val):
        self._root = self.insert_helper(self._root, val)

    def insert_helper(self, node, val):
        if node is None:
            return TreeNode(val)
        if val < node.val:
            node.left = self.insert_helper(node.left, val)
        elif val > node.val:
            node.right = self.insert_helper(node.right, val)
        else:
            return

        self.update_height(node)
        return node.rotation(node)

    def delete(self, val):
        self._root = self.delete_helper(self._root,val)

    def delete_helper(self, node, val):
        if node is None:
            return
        if val < node.val:
            node.left = self.delete_helper(node.left, val)
        elif val > node.val:
            node.right = self.delete_helper(node.right,val)
        else:
            if node.left is None or node.right is None:
                child = node.left or node.right
                if child is not None:
                    node = child
                else:
                    return None
            else:
                min_node = node.right
                while min_node.left is not None:
                    min_node = min_node.left
                node.val = min_node.val
                node.right = self.delete_helper(node.right, min_node.val)

        self.update_height(node)
        return node.rotation(node)

```







## week 05

### 1. Hashing



### 2.List



### 3. linked list

双向链表 ：DOUBLE LINKED LIST

循环链表：CIRCULAR  LIST
