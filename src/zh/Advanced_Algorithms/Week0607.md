---
title: 高级算法——第6, 7周查漏补缺
icon: python
date: 2024-11-11 21:08:11
author: XiaoXianYue
isOriginal: true
category: 
    - 大三上
    - 高级算法课件
tag:
    - 大三上
    - 高级算法课件
sticky: false
star: false
article: true
timeline: true
image: false
navbar: true
sidebarIcon: true
headerDepth: 5
lastUpdated: true
editLink: false
backToTop: true
toc: true
---

## Week 06

### Dijkstra’s algorithm

#### 手写过程

<img src="./Week06.assets/e562381f303733f11fcb3c19105da6a.jpg" alt="e562381f303733f11fcb3c19105da6a" style="zoom:50%;" />

| node | 最开始 | while 1开始时 | while 2开始时 | while 3开始时 | while 4开始时 | while 5开始时 | while 6开始时 |
| ---- | ------ | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- |
| A    | ~      | 0             | 0             | 0             | 0             | 0             | 0             |
| B    | ~      | ~             | 1             | 1             | 1             | 1             | 1             |
| C    | ~      | ~             | 4             | 3             | 3             | 3             | 3             |
| D    | ~      | ~             | ~             | 6             | 4             | 4             | 4             |

==**第一次 while：**==

1. 第一次 while 开始时：`priority_queue:[(0,A)]`

2. `current_distance, currentg_node = 0, A`, 弹出 `(0, A)`
3. `0 < distances[A] = ~`, 循环继续
4. 遍历 `graph[A]. neighbor:[B;C]; weight:[1,4]`
5. 先 B。`distance = 0 + 1`，1 < ~，加入距离表。 `(1, B)`加入第一步那个队列
6. 再C。`distance = 0 + 4`，4 < ~，假如距离表。`(4, C)`加入第一步那个队列

==**第二次 while**==

1. `priority_queue:[(1, B), (4, C)]`
2. `current_distance, currentg_node = 1, B`，弹出 `(1, B)`

3. `1 = distance[B] = 1`, 循环继续
4. 遍历 `graph[B]. neighbor:[A,C,D],weight[1,2,5]`
5. A. `distance = 0 + 1`, 1 >  0, 不加入距离表也不加入队列。
6. C. `distance = 1 + 2`, 3 < 4, 修改距离表，`(3, C)`加入队列
7. D.`distance = 1 + 5`, 6 < ~, 修改距离表，`(6, D)`加入队列

==**第三次 while**==

1. `priority_queue:[(4,C),(3,C),(6,D)]`
2. `current_distance, current_node = 3, C`, 弹出 `(3, C)`
3. 3 = distances[C] = 3, 循环继续
4. 遍历 `neighbor = [A, B, D], weight = [4, 2, 1]`

5. A. 跳过，类似上面
6. B。 `distance = 3 + 2， 5 > 1`跳过
7. D。 `distance = 3 + 1，4 < 6`，修改距离表，加入队列

==**第四次 while**==

1. `priority_queue: [(4, D),(4,C),(6，D)]`
2. 假设这里先弹出 C。`current_distance, current_node = 4, C`, 弹出 `(4，C)`
3. 4 > distances[C] = 3, 循环结束。

==**第五次 while**==

1. `priority_queue: [(4, D),(6，D)]`

2. `current_distance, currentg_node = 4, D`, 弹出 `(4，D)`

3. 4 = 4，循环继续
4. 遍历 `neighbor = [B, C], weight = [1, 5]`
5. B. `distance = 4 + 1, 5 > 1`跳过
6. C. `distance = 4 + 5, 9>3`跳过

**==第六次 while==**

1. `priority_queue: [(6，D)]`
2. `current_distance, currentg_node = 6, D`, 弹出 `(6，D)`
3. 6 > distances[D] = 4，循环结束。

**`priority_queue`空了，跳出 while 循环。**

#### 代码

```python
import heapq

def dijkstra(graph, start):
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    priority_queue = [(0, start)]

    while priority_queue:
        current_distance, current_node = heapq.heappop(priority_queue)
        if current_distance > distances[current_node]:
            continue
        for neighbor,weight in graph[current_node].items():
            distance = current_distance + weight

            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))

    return distances


graph = {
    'A': {'B': 1, 'C': 4},
    'B': {'A': 1, 'C': 2, 'D': 5},
    'C': {'A': 4, 'B': 2, 'D': 1},
    'D': {'B': 5, 'C': 1}
}

# 从起点A运行 Dikjkatra 算法,计算到所有其他节点的最短路径
start_node = 'A'
shortest_path = dijkstra(graph, start_node)

# 输出从起点到其他所有结点的最短距离
print(f'从节点{start_node}到其他节点的最短距离为：')
for node, distance in shortest_path.items():
    print(f"{start_node}->{node}: {distance}")
```



### Prim’s algorithm

#### 手写过程

<img src="./Week06.assets/942be49dcef642a79a698dd4e2ccb7a.jpg" alt="942be49dcef642a79a698dd4e2ccb7a" style="zoom:50%;" />

start 设做 A

把 A 放到已访问的列表。

未访问的列表里：B，C，D

把与 A 相连的边全部放到 `edge_heap`里，作为候选边。

`edge_heap = [(4,A,D),(3,A,C),(1,A,B)]`

**while 1：**

1. 候选边列表把目前最小边弹出。`cost, u, v = 1,A,B`

2. B 不在已访问的列表里面。

3. 把这条边加入最小生成树。`spanning_tree = [A,B,1]`

4. 把 B 添加到已访问的列表，从未访问的列表移除。

5. 对于与 B 相连的所有边：如果另一个节点在未访问列表里，加入候选边列表 `[(4,A,D),(3,A,C),(2,B,C),(5,B,D)]`

**while 2:**

1. 候选边列表把目前最小边弹出。`cost, u, v = 2,B,C`
2. C 不在已访问的列表里面。
3. 添加到生成树里。`spanning_tree = [A,B,1], [B,C,2]`
4. 把C添加到已访问列表，从未访问的列表移除。
5. 对于与 C相连的所有边，如果另一个节点没有被访问过，加入候选列表 `[(4,A,D),(3,A,C),(5,B,D),(6,C,D)]`

**while 3:**

1. 候选边列表把目前最小边弹出。`cost, u, v = 3,A,C`
2. C 在已访问列表里。跳过。

**while 4：**

1. 候选边列表把目前最小边弹出。`cost, u, v = 4,A,D`
2. D不在已访问的列表里
3. 添加到生成树。`spanning_tree = [A,B,1], [B,C,2],[A,D,4]`
4. 把 D 添加到已访问列表里。
5. 对于与D相连的所有边，进行遍历。结果邻居节点都在已访问列表。跳过

**while 5:**

1. 候选边列表把目前最小边弹出。`cost,u,v = 5,B,D`
2. D 已经在已访问的列表里。跳过

**while 6：**

同 5

最后生成树里的边：

`spanning_tree = spanning_tree = [A,B,1], [B,C,2],[A,D,4]`



#### 代码

```python
import heapq


def prim(graph, start):
    reached_set = set([start_node])  # 已经访问的节点集合
    unreached_set = set(graph.keys()) - reached_set  # 未访问的节点集合
    spanning_tree = []
    edge_heap = []

    for neighbor, cost in graph[start].items():
        heapq.heappush(edge_heap, (cost, start, neighbor))

    while unreached_set:
        cost, u, v = heapq.heappop(edge_heap)

        if v in unreached_set:
            spanning_tree.append((u, v, cost))
            reached_set.add(v)
            unreached_set.remove(v)

            for neighbor, edge_cost in graph[v].items():
                if neighbor in unreached_set:
                    heapq.heappush(edge_heap, (edge_cost, v, neighbor))
    return spanning_tree


# 示例图结构（邻接表表示）
graph = {
    'A': {'B': 1, 'C': 3, 'D': 4},
    'B': {'A': 1, 'C': 2, 'D': 5},
    'C': {'A': 3, 'B': 2, 'D': 6},
    'D': {'A': 4, 'C': 6, 'B': 5}
}

# 调用 Prim 算法，选择起始节点为 'A'
start_node = 'A'
mst = prim(graph, start_node)

# 输出最小生成树的边
print("最小生成树的边：")
for edge in mst:
    print(f"{edge[0]} - {edge[1]} (权重: {edge[2]})")
```



### Kruskal’s algorithm

```python
class Edge:
    def __init__(self, u, v, weight):
        self.u = u
        self.v = v
        self.weight = weight


class unionfind:
    def __init__(self, vertices):
        self.parent = {vertex: vertex for vertex in vertices}

    def find(self, vertex):
        if self.parent[vertex] != vertex:
            self.parent[vertex] = self.find(self.parent[vertex])
        return self.parent[vertex]

    def union(self, u, v):
        root_u = self.find(u)
        root_v = self.find(v)
        if root_u == root_v:
            return False
        self.parent[root_v] = root_u
        return True


def kruskal(vertices, edge):
    uf = unionfind(vertices)
    sorted_edges = sorted(edge, key=lambda edge: edge.weight)
    mst = []
    for edge in sorted_edges:
        if uf.union(edge.u, edge.v):
            mst.append(edge)
            if len(mst) == len(vertices) - 1:
                break
        else:
            continue
    return mst

if __name__ == '__main__':
    vertices = ['A', 'B', 'C', 'D', 'E', 'F']
    edges = [
        Edge('A', 'B', 4),
        Edge('A', 'F', 2),
        Edge('B', 'C', 6),
        Edge('B', 'F', 5),
        Edge('C', 'D', 3),
        Edge('C', 'E', 7),
        Edge('D', 'E', 8),
        Edge('D', 'F', 4),
        Edge('E', 'F', 1)
    ]

    mst = kruskal(vertices, edges)
    print("最小生成树的边为：")
    total_weight = 0
    for edge in mst:
        print(f"{edge.u} -> {edge.v} -> {edge.weight}")
        total_weight += edge.weight
    print(f"最小生成树的权重总和：{total_weight}")
```

