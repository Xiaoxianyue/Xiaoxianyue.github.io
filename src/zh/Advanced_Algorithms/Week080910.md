---
title: 高级算法——第8,9,10周查漏补缺
icon: python
date: 2024-11-11 21:08:11
author: XiaoXianYue
isOriginal: true
category: 
    - 大三上
    - 高级算法课件
tag:
    - 大三上
    - 高级算法课件
sticky: false
star: false
article: true
timeline: true
image: false
navbar: true
sidebarIcon: true
headerDepth: 5
lastUpdated: true
editLink: false
backToTop: true
toc: true
---

## Lecture 08

### 时间复杂度

![image-20241115143641761](./Week080910.assets/image-20241115143641761.png)

#### 1. constant $O(1)$

```python
a = [11, 22, 33, 44, 55]
b = [10, 8, 7]

print(a[0])
print(b[0])
```

如插值搜索（最好情况）的时间复杂度。



#### 2. Logarithmic $O(log n)$

如二分搜索的时间复杂度。

<img src="./Week080910.assets/image-20241115145201611.png" alt="image-20241115145201611" style="zoom:33%;" />

每次都会将要操作的对象减半。符合 log 函数的定义。



#### 3. linear $O(n)$

伪代码：

```python
FIND (A, target) 
	n ← A.length 
	FOR (i FROM 0 TO n) 
		IF (A[i]=target) 
			RETURN TRUE 
	RETURN FALSE 
```



#### 4. log linear $O(n log n)$

- O (n log n) means do O (log n) n times.
- So e.g. do 6 binary searches

```python
def linear_log_recur(n: int) -> int:
    """线性对数阶"""
    if n <= 1:
        return 1
    # 一分为二，子问题的规模减小一半
    count = linear_log_recur(n // 2) + linear_log_recur(n // 2)
    # 当前子问题包含 n 个操作
    for _ in range(n):
        count += 1
    return count
```



#### 5. polynomial $O(n^k)$

嵌套循环。

插值排序：

```python
INSERTION-SORT(A)
	for j ← 1 to length[A]				(n times)
		key ← A[j]						(n times)
		i ← j-1							(n times)
		while i > 0 and A[i] > key		(n*n times)
			A[i+1] ← A[i]				(n*n times)
			i ← i+1					(n*n times)
		A[i+1] ← key 					(n times)
```



#### 6. exponential  $O(2^n)$

斐波那契数列：

```python
FIBONACCI(num)
	IF num <=1
		return num
	return FIBONACCI (num-2) + FIBONACCI(num-1)
```



#### 7. factorial  $O(n!)$

```python
def factorial_recur(n):
    if n == 0:
        return 1
    count = 0
    for i in range(n):
        count += factorial_recur(n - 1)
        
    return count
```



### NP-Hard problems

- NP - Non deterministic Polynomial time complexity
- A non deterministic algorithm can exhibit different behaviours on different runs for the same input variables.

#### 1. Exhaustive search —— Travelling saleman

这是关于**穷举搜索（Exhaustive Search）**的概述图片，介绍了穷举搜索的一些特点。这类搜索方法遍历所有可能的解，以找到满足问题条件的解。穷举搜索适用于问题规模较小的情况，因为它的时间和空间成本会随着问题规模的增加而迅速增长。

穷举法：

```python
import itertools  # 导入Python的itertools库，用于处理迭代器

# 定义边的列表，即城市之间的距离
dists = [
    ['A', 'B', 20], ['A', 'C', 35], ['A', 'D', 42],
    ['B', 'A', 20], ['B', 'C', 34], ['B', 'D', 30],
    ['C', 'A', 35], ['C', 'B', 34], ['C', 'D', 12],
    ['D', 'A', 42], ['D', 'B', 30], ['D', 'C', 12]
]


# 定义函数，获取所有可能的排列（即可能的路径）
def get_and_convert_perm_list(dests):
    # 使用itertools.permutations生成所有排列
    perm_list = list(itertools.permutations(dests))  # 生成一个包含所有排列的列表（列表中的元素是元组）
    new_perm_list = []  # 定义一个新的列表，用于存储列表形式的排列

    # 将元组转换为列表（方便后续处理）
    for item in perm_list:
        new_perm_list.append(list(item))

    return new_perm_list  # 返回转换后的排列列表


# 定义函数，计算每条路径的总距离
def TSP_get_dists(dests, dists):
    results = []  # 用于存储所有结果的列表
    perm_list = get_and_convert_perm_list(dests)  # 获取所有排列列表

    # 遍历每一个排列（即一条路径）
    for item in perm_list:
        item.append(item[0])  # 将起点添加到路径末尾，形成回路
        total_dist = 0  # 初始化总距离

        # 计算该路径的总距离
        for i in range(len(item) - 1):  # 遍历路径中的每对相邻城市
            for dist in dists:  # 匹配路径中的每对城市与距离列表中的城市对
                if item[i] == dist[0] and item[i + 1] == dist[1]:  # 找到匹配的城市对
                    total_dist = total_dist + dist[2]  # 将对应的距离加到总距离中

                    # 如果已经遍历完该路径，记录总距离
                    if i == len(item) - 2:
                        item.append(total_dist)  # 将总距离添加到路径的末尾
                        print(item)  # 打印路径及其总距离，便于观察
                        results.append(item)  # 将该路径及总距离添加到结果列表中

    return results  # 返回所有结果的列表


# 调用函数，计算包含城市A、B、C、D的所有路径及其总距离
TSP_get_dists(['A', 'B', 'C', 'D'], dists)
```



#### 2. Heuristics ——Travelling saleman

启发式函数能在合理的时间范围内产生一个足以解决问题的解决方案。该解决方案可能不是最佳解决方案，但可能仍然很有价值，因为它不需要很长时间就能找到。

销售员从一个随机城市开始，访问最近的城市，直到访问完所有城市为止

```python
# 定义城市之间的距离
dists = [
    ['A', 'B', 20], ['A', 'C', 35], ['A', 'D', 42],
    ['B', 'A', 20], ['B', 'C', 34], ['B', 'D', 30],
    ['C', 'A', 35], ['C', 'B', 34], ['C', 'D', 12],
    ['D', 'A', 42], ['D', 'B', 30], ['D', 'C', 12]
]

# 定义一个函数，用于查找两个城市之间的距离
def find_distance(city1, city2, dists):
    for dist in dists:
        if dist[0] == city1 and dist[1] == city2:
            return dist[2]
    return float('inf')  # 如果没有找到对应的距离，返回无穷大

# 定义最近邻算法的主函数
def nearest_neighbour(start, dists):
    unvisited = ['A', 'B', 'C', 'D']  # 未访问的城市
    visited = []  # 已访问的城市
    connections = []  # 记录访问路径的连接

    u = start  # 从起始城市开始
    visited.append(u)  # 将起始城市添加到已访问列表
    unvisited.remove(u)  # 从未访问列表中移除起始城市

    # 当还有未访问的城市时，继续循环
    while unvisited:
        # 找到从当前城市到未访问城市的最小距离的边
        min_distance = float('inf')
        next_city = None

        for city in unvisited:
            distance = find_distance(u, city, dists)  # 查找距离
            if distance < min_distance:  # 如果找到更小的距离
                min_distance = distance
                next_city = city

        # 更新当前城市为找到的下一个城市
        u = next_city
        connections.append((visited[-1], u, min_distance))  # 添加边到连接列表
        visited.append(u)  # 将找到的城市添加到已访问列表
        unvisited.remove(u)  # 从未访问列表中移除该城市

    return connections  # 返回完整的访问路径和距离

# 调用函数，并输出结果
start_city = 'A'
route = nearest_neighbour(start_city, dists)

# 输出路径
print("访问路径及距离：")
for connection in route:
    print(f"从 {connection[0]} 到 {connection[1]} 的距离为 {connection[2]}")
```



#### 3. Local search

::: tabs

@tab

<img src="./Week080910.assets/image-20241115164142558.png" alt="image-20241115164142558" style="zoom:25%;" />

@tab

<img src="./Week080910.assets/image-20241115164159502.png" alt="image-20241115164159502" style="zoom:25%;" />

@tab

<img src="./Week080910.assets/image-20241115164221252.png" alt="image-20241115164221252" style="zoom:25%;" />

@tab

<img src="./Week080910.assets/image-20241115164316365.png" alt="image-20241115164316365" style="zoom:25%;" />

:::

```python
import random

# 定义城市之间的距离
dists = {
    ('A', 'B'): 20, ('A', 'C'): 35, ('A', 'D'): 42,
    ('B', 'A'): 20, ('B', 'C'): 34, ('B', 'D'): 30,
    ('C', 'A'): 35, ('C', 'B'): 34, ('C', 'D'): 12,
    ('D', 'A'): 42, ('D', 'B'): 30, ('D', 'C'): 12
}

# 定义计算路径总距离的函数
def distance(route, dists):
    total_distance = 0
    for i in range(len(route) - 1):
        total_distance += dists[(route[i], route[i+1])]
    total_distance += dists[(route[-1], route[0])]  # 回到起始点
    return total_distance

# 定义变异函数，用于2-opt交换
def mutate_2_opt(route):
    i, j = random.sample(range(1, len(route)), 2)
    if i > j:
        i, j = j, i
    # 执行2-opt交换
    new_route = route[:i] + route[i:j+1][::-1] + route[j+1:]
    return new_route

# 定义TSP的局部搜索算法
def local_search_tsp(startroute, dists, i_max=100):
    current_route = startroute  # 初始化为起始路径
    min_distance = distance(current_route, dists)  # 计算初始路径的总距离

    for i in range(i_max):
        new_route = mutate_2_opt(current_route)  # 生成一个新路径
        new_distance = distance(new_route, dists)  # 计算新路径的距离

        if new_distance < min_distance:  # 如果新路径更短，则更新最优解
            min_distance = new_distance
            current_route = new_route

    return current_route, min_distance  # 返回最优路径和最短距离

# 定义初始路径
start_route = ['A', 'B', 'C', 'D']

# 调用局部搜索算法并输出结果
best_route, best_distance = local_search_tsp(start_route, dists)

print("最优路径:", best_route)
print("最优路径的总距离:", best_distance)
```

### 4.  Simulated annealing

